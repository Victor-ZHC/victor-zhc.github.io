[{"content":"编译与链接 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 编译器编译过程包括三个步骤：\n预处理：程序被交给 预处理器（Preprocessor） 。预处理器用于执行以#开头的指令，预处理指令用于对代码内容进行修改。 编译：修改后的代码由 编译器（Compiler） 处理。编译器讲代码编译为机器指令。 链接： 连接器（Linker） 将机器指令与其他附加代码进行整合，最终产生可执行文件。 目前GCC是最流行的C语言编译器，编译C文件可使用gcc -o output.o file.c命令。 ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/introduction/","summary":"运行Hello World","title":"简介"},{"content":"基本语法规则 变量使用${}方式取值，但是在IF控制语句中是直接使用变量名， 指令(参数 1 参数 2 \u0026hellip;)参数使用括弧括起，参数之间使用空格或分号分开， ADD_EXECUTABLE(hello main.c func.c)\nADD_EXECUTABLE(hello main.c;func.c)\n指令是大小写无关的，参数和变量是大小写相关的。但推荐全部使用大写指令。 指令 project 语法 PROJECT(projectnema [CXX] [C] [Java])\n作用 指定工程名和工程语言，并隐式定义了两个全局变量：\u0026lt;projectname\u0026gt;_SOURCE_DIR和\u0026lt;projectname\u0026gt;_BINARY_DIR。同时cmake系统也帮助我们预定义了 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR变量，他们的值分别跟前者一致。\nset 语法 SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])\n作用 显式的定义变量。\n对于单个文件，可以使用SET(SRC_LIST main.c)，如果有多个源文件，也可以定义成：SET(SRC_LIST main.c t1.c t2.c)。\nmessage 语法 MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] \u0026quot;message to display\u0026quot; ...)\n作用 向终端输出用户定义的信息。包含三种类型：\nSEND_ERROR：产生错误，生成过程被跳过， SATUS：输出前缀为-的信息， FATAL_ERROR：立即终止所有cmake过程。 add_executable 语法 ADD_EXECUTABLE(executablename ${SRC_LIST})\n作用 生成一个文件名为executablename的可执行文件，相关的源文件是SRC_LIST中定义的源文件列表。\n也可以忽略掉SRC_LIST列表中的源文件后缀，比如可以写成ADD_EXECUTABLE(t1 main)，cmake会自动的在本目录查找main.c或者main.cpp等，但最好不要偷这个懒，以免这个目录确实存在main.c和main。\nadd_subdirectory 语法 ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])\n作用 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL参数的含义是将这个目录从编译过程中排除。\ninstall(TARGETS) 语法 INSTALL(TARGETS targets... [[ARCHIVE|LIBRARY|RUNTIME] [DESTINATION \u0026lt;dir\u0026gt;] [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT \u0026lt;component\u0026gt;] [OPTIONAL] ] [...] ) 用法 安装的内容可以包括目标二进制、动态库、静态库。\n参数中的TARGETS后面跟的就是我们通过ADD_EXECUTABLE或者ADD_LIBRARY定义的目标文件，可能是可执行二进制、动态库、静态库。目标类型也就相对应的有三种：\nARCHIVE：特指静态库， LIBRARY：特指动态库， RUNTIME：特指可执行目标二进制。 DESTINATION定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候CMAKE_INSTALL_PREFIX将无效。\n例：\n/** * 可执行二进制myrun安装到 ${CMAKE_INSTALL_PREFIX}/bin 目录 * 动态库libmylib安装到 ${CMAKE_INSTALL_PREFIX}/lib 目录 * 静态库libmystaticlib安装到 ${CMAKE_INSTALL_PREFIX}/libstatic 目录 */ INSTALL(TARGETS myrun mylib mystaticlib RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION libstatic ) ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/cmake/grammer/","summary":"CMake的所有用法","title":"语法"},{"content":"基础 变量和基本类型 unsigned char 8bit，表示范围0到255，若超出赋值，则取该值对256求模后的值 C++字符串字面值由编译器自动在末尾加上空字符 直接初始化效率高于复制初始化 直接初始化：int ival(1024); 复制初始化：int ival = 1024; 变量定义分配存储空间，声明仅向程序表明变量类型和名字，不分配存储空间 extern关键字，仅声明变量而不定义 extern int i; 默认情况下，访问级别：struct的成员为public，而class的成员private 箭头操作符 (*p).foo; // 获得p指向对象的成员变量foo p-\u0026gt;foo; // 与上面等价 数组 sizeof：对对象求内存大小（对象数据类型的大小） const char *words[] = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;}; size_t st1 = sizeof(words); size_t st2 = sizeof(char *); // 相当于string cout \u0026lt;\u0026lt; st1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; st2 \u0026lt;\u0026lt; endl; size_t size = st1 / st2; cout \u0026lt;\u0026lt; size \u0026lt;\u0026lt; endl; 输出： 16 8 2 strlen：求字符串的实际长度，从开始到遇到第一个\\0 char a[10] = {\u0026#39;\\0\u0026#39;}; char b[10] = \u0026#34;123\u0026#34;; cout \u0026lt;\u0026lt; strlen(a) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; strlen(b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(a) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sizeof(b) \u0026lt;\u0026lt; endl; 输出： 0 3 10 10 指针和引用 指针 可能的取值： 保存一个对象的地址 保存某对象后面的对象 0值 引用 绑定对象的别名，必须被初始化 int ival = 1024; int \u0026amp;refVal = ival; 作用在引用上的所有操作实际上都是该引用绑定的对象上 const引用是指向const对象的引用 swap函数，交换实参的值，需要将形参定义为引用类型： void swap(int \u0026amp;v1, int \u0026amp;v2) { int tmp = v2; v2 = v1; v1 = tmp; } 调用： swap(i, j) 举例 int ival = 1024; int *pi = 0; // 初始化为0值 int *pi2 = \u0026amp;ival; // 初始化为ival的地址 int *pi3; // 未初始化 pi = pi2; // pi和pi2保存同一对象的地址 注：\u0026amp; 取地址操作符 // 指针 \u0026amp; 引用 int ival = 1024; int \u0026amp;refVal = ival; cout \u0026lt;\u0026lt; refVal \u0026lt;\u0026lt; endl; int *p = \u0026amp;refVal; // p保存ival的地址，*p保存值 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; int *p2 = p; cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt; endl; 输出： 1024 0x7ffeefbff618 1024 0x7ffeefbff618 1024 下标和指针 int ia[] = {0, 2, 4, 6, 8}; int *p = \u0026amp;ia[2]; // p指向数组下标为2的元素 int j = p[1]; // p[1]等价于*(p+1)，p[1]也就是ia[3] int k = p[-1]; // p[-2]也就是ia[0] 顺序容器 sequential container 三种顺序容器类型： vector（可变长数组，可扩容） list（双向链表） deque（基于双端队列，用链表连接数组） 注：list和deque提供了首部插入push_front和尾部插入push_back，首部删除pop_front和尾部删除pop_back 关联容器 associative container 与顺序容器差别 通过key存储和读取元素 三种关联容器类型： map #include \u0026lt;map\u0026gt; map\u0026lt;string,int\u0026gt; word_count; word_count[\u0026#34;Anna\u0026#34;] = 1; cout \u0026lt;\u0026lt; word_count[\u0026#34;Anna\u0026#34;] \u0026lt;\u0026lt; endl; set multimap和multiset 键可以多次出现 继承 virtual是基类期待派生类重新定义的，派生类动态绑定，注：成员函数默认为：非虚函数 构造函数后加冒号，是：成员变量的初始化 在成员函数的形参后面写上=0，则成员函数为纯虚函数，包含纯虚函数的类不能被实例化 const修饰成员函数，防止成员变量被修改 virtual double net_price(std::size_t n) const { return n * price; } ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/cpp/grammer/","summary":"C++关键语法","title":"语法"},{"content":" auto enum restrict unsigned break extern return void case float short volatile char for signed while const goto sizeof _Bool continue if static _Complex default inline struct _Imaginary do int switch double long typedef else register union 注意： 粗体字为C99关键字\n可以按照功能对关键字进行分类\n非常见：auto、register、volatile、goto 存储相关：const、extern、register、volatile、static、auto、signed、unsigned 数据类型：char、short、int、float、long、double、struct、union、enum、void 逻辑控制：if、else、for、while、do、break、continue、return、default、switch、case、goto 特殊用途：sizeof、typedef ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/key_word/","summary":"很关键","title":"关键字"},{"content":"输出函数 printf函数是用于显示“格式串”的内容，用法为：\nprintf(格式串, 表达式1, 表达式2, ...)\n格式串由普通字符和转换说明（conversion specification）组成。\n转换说明 结构 转换说明的结构为：%m.pX或%-m.pX，其中：\nm为最小字段宽度，其指定了需要显示的最少字符的数量，若字符数小于该值，则会在字符左边填充空格。若在m前放置-号，则会在字符串右边填充空格。 p为精度，对于不同的X，p的含义不同 d：代表十进制显示的个数，若不足，则在前面补充0 e：指数形式浮点数，p规定小数点后位数 f：小数点后位数 数据类型 整数：存储长度 + 进制 d、u、o、x：十进制、十进制无符号、八进制、十六进制 s、l：短整数、长整数 浮点数： f：以小数输出单、双精度浮点数 e：以指数输出单、双精度浮点数 g：以%f或%e中较短的输出宽度输出单、双精度实数 字符： c：单字符 s：字符串 输入函数 scanf函数根据特定的格式读取输入。\nscanf(格式串, \u0026amp;变量1, \u0026amp;变量2, ...)\n工作方式 当程序执行到scanf(\u0026quot;%d\u0026quot;, \u0026amp;a);时，程序向CPU发出指令，要求其先检测输入缓冲内有没有数据，本程序内输入缓冲内没有数据，CPU开始等待输入设备（键盘）向输入缓冲内输入数据，这里输入一个“2”，输入后按enter，此时2和换行符一并被输入设备写入输入缓冲，输入缓冲检测到有回车进来了，CPU开始执行读取指令，将2读取后将其从输入缓冲清除，从输入缓冲将数据“2”赋值给a，由于a是一个具体的地址空间变量，所以赋值结束后，CPU将a的值写入输入缓冲，对于笔记本电脑而言，a的保存输出设备就是电脑硬盘，所以电脑硬盘就是输出设备。\n对于不同数据类型处理方式：\n%d：对于整型数据的输入，也就是说”%d”类型的输入，scanf默认的分割符是所有的空白字符(空格，回车和指标符都行)。也就是说如果一个scanf函数中出现scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b) ，那么用任何一个空白字符来分隔两个整数a,b的值，变量a,b都可以接收到正确的输入。另外，要注意的是，scanf对于数字输入，会忽略输入数据项前面的空白字符。 %s：scanf对于字符串输入的处理和对整数类似，会忽略前导的空白字符，而且默认的分隔符是所有的空白字符。但是，要注意的是，由于C语言中，没有string类型，都是用char型数组来表示。因此，scanf会为每一个输入的字符串最后加一个‘\\0’ （NULL）。 %c：scanf在处理对字符数据的输入时，既不会忽略前导空白字符，默认也没有任何分隔字符。所有的字符，包括空白字符都会被当成输入字符。 C语言缓冲区 缓冲区的三种类型 全缓冲 在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是对磁盘文件的读写。\n行缓冲 scanf()函数的缓冲类型就是这个，在这种情况下，当在输入和输出中遇到换行符时，执行真正的I/O操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I/O操作。典型代表是键盘输入数据。\n不带缓冲 也就是不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来。\nC语言操作缓冲区 对于以下程序：\n#include \u0026lt;stdio.h\u0026gt; void main() { char a ,b ; printf(\u0026#34;请输入a和b的值：\u0026#34;); scanf(\u0026#34;%c%c\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;a=%c,b=%c\\n\u0026#34;,a,b); printf(\u0026#34;请输入a和b的值：\u0026#34;); scanf(\u0026#34;%c%c\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;a=%c,b=%c\\n\u0026#34;,a,b); } 输出如图： 分析：\n1~5：行程序正常执行； 6：程序走到这里，scanf检测到输入缓冲区没有字符，开始等待输入；我们输入了两个字符AB，这是我们一共在按键上依次按下”A”，”B”，“enter”，于是缓冲区现在有这三个字符；AB被分别分给了字符变量a，b；并且被清除了；于是缓冲区内就剩下了“enter”； 7：程序正常输出a,b值； 8：正常执行程序； 9：程序走到这里，scanf检测缓冲区内有字符，但是只有一个字符“enter”，不够再次分配两个变量的，所以程序让再输入一个字符；可是我们输入了两个字符，AB；程序结束后，a被赋值“enter”，b被赋值A，这时缓冲区不仅将会剩下一个B字符，还会剩下一个“enter”；这个缓冲区的内容会随着程序的结束而被消除，由于不操作了，所以我们感觉不到他俩的存在； 10：a，b再次被输出，a被输出了回车，所以换行了，a被输出了A； 程序结束； 缓冲区的刷新 下面几种情况将引起缓冲区刷新，也就是清空所有数据：\n缓冲区被写满 执行flush语句 执行endl语句 关闭文件 fflush(stdin)函数清除缓冲区\n#include \u0026lt;stdio.h\u0026gt; void main() { char a ,b ; printf(\u0026#34;请输入a和b的值：\u0026#34;); scanf(\u0026#34;%c%c\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;a=%c,b=%c\\n\u0026#34;,a,b); printf(\u0026#34;请输入a和b的值：\u0026#34;); fflush(stdin); //清除输入缓冲区； scanf(\u0026#34;%c%c\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;a=%c,b=%c\\n\u0026#34;,a,b); } 结果如下： ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/io/","summary":"输出你想要的格式","title":"输入输出"},{"content":"算数运算符 一元运算符 二元加法类运算符 二元乘法类运算符 + 一元正号运算符 + 加法运算符 * 乘法运算符 - 一元负号运算符 - 减法运算符 / 除法运算符 % 求余运算符 /运算符在进行整数运算时仅产生整数结果 /与%在进行附属操作时结果难以确定，如果两个操作数中有一个是负数，那么结果可以向上或向下取整（-9 / 7 = -1 or -2），取余也与实现有关（-9 % 7 = -2 or 5），在C99中，除法总是向0截取（-9 / 7 = -1），i % j的正负与i相同（-9 % 7 = -2） 为解决表达式中包含多个运算符时产生的二义性问题，运算符引入优先级和结核性：\n运算符优先级：运算符按照优先级从高到低的次序进行计算。+与-的优先级低于*与/ 结核性：在优先级一致情况下，按照结核性依次计算。 赋值运算符 C语言将=看做是运算符之一，v = e产生的结果是e。\n符合赋值：+=、-=、*=、\\=\u0026hellip;\n自增/自减运算符 自增（++）、自减（\u0026ndash;）运算符既可以作为前缀运算符也可作为后缀运算符。\n注：如i++ + ++i这种情况会导致undefined behavior，千万不要写出这种语句。 逗号运算符 ,运算符用于连接多个表达式，并返回最末尾表达式的值。\n运算符表 优先级 名称 符号 结合性 1 数组取下值 [] 左 1 函数调用 () 左 1 取结构体和联合的成员 . -\u0026gt; 左 1 自增（后缀） ++ 左 1 自减（后缀） -- 左 2 自增（前缀） ++ 右 2 自减（前缀） -- 右 2 取地址 \u0026amp; 右 2 间接寻址 * 右 2 一元正号 + 右 2 一元负号 - 右 2 按位求反 ~ 右 2 逻辑非 ! 右 2 计算空间 sizeof 右 3 强制类型转换 () 右 4 乘法类运算符 * / % 左 5 加法类运算符 + - 左 6 位移 \u0026lt;\u0026lt; \u0026gt;\u0026gt; 左 7 关系 \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 左 8 判等 == != 左 9 按位与 \u0026amp; 左 10 按位异或 ^ 左 11 按位或 ` ` 12 逻辑与 \u0026amp;\u0026amp; 左 13 逻辑或 ` 14 条件 ?: 右 15 赋值 = *= /= %= += -= \u0026lt;\u0026lt;= \u0026gt;\u0026gt;= \u0026amp;= ^= != 右 16 逗号 , 左 ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/operator/","summary":"原来加减乘除还有这么多门道","title":"运算符"},{"content":"选择语句 逻辑表达式 关系运算符（\u0026lt;、\u0026gt;、\u0026gt;=、\u0026lt;=）判等运算符（==、!=）逻辑运算符（\u0026amp;\u0026amp;、||）连接的表达式，结果返回真（1）或假（0），C语言中==号仅能用于基本类型上的判断，字符串判等需要使用strcmp()函数。\n注：逻辑运算符拥有短路效应。\nif语句 if (bool) { /* statements */ } else if (bool) { /* statements */ } else { /* statements */ } else语句总是与上一个距自己最近的if语句相匹配。\n三元条件表达式 s1 ? s2 : s3;\ns1成立，则s2，否则s3。\nswitch语句 switch(表达式) { case 常量表达式 : /* statements */ ... case 常量表达式 : /* statements */ default : /* statements */ } 一旦传入表达式符合某一常量表达式会将后面所有语句执行，不要忘记在使用break跳出switch。\n循环语句 while语句 while (bool) { /* statements */ } do语句 do { /* statements */ } while (bool); for语句 for (表达式1; 表达式2; 表达式3) { \\\\ 表达式2返回bool类型 /* statements */ } 执行顺序：表达式1 -\u0026gt; 表达式2 -\u0026gt; 语句 -\u0026gt; 表达式3\n退出循环语句 break语句：吧程序控制从包含该语句的最内侧while，do、for或switch语句中转移出来。 continue语句：直接将程序控制转至循环体末尾。 goto语句：直接将程序跳转至程序任意位置。 标识符 : /* statements */ goto 标识符; ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/control_statements/","summary":"基本操作","title":"控制语句"},{"content":"整数类型 整数类型根据存储数据大小可以分为长整型（long）与短整型（short），根据是否存储负数分为有符号型（signed）与无符号型（unsigned），故整数类型共有6种：\nshort (int) unsigned short (int) int unsigned int long (int) unsigned long (int) 根据机器不同，取值范围也不同，以下是详细对比： 16位机\n类型 最大 最小 大小（字节） short -32768 32767 2 unsigned short 0 65535 2 int -32768 32767 2 unsigned int 0 65535 2 long -2147483648 2147483647 4 unsigned long 0 4294967295 4 32位机\n类型 最大 最小 大小（字节） short -32768 32767 2 unsigned short 0 65535 2 int -2147483648 2147483647 4 unsigned int 0 4294967295 4 long -2147483648 2147483647 4 unsigned long 0 4294967295 4 64位机\n类型 最大 最小 大小（字节） short -32768 32767 2 unsigned short 0 65535 2 int -2147483648 2147483647 4 unsigned int 0 4294967295 4 long -9223372036854775808 9223372036854775807 8 unsigned long 0 18446744073709551615 8 有符号型整数在计算机中均已补码的形式存储，其中最高位表示符号位，正数的补码为其源码，负数的补码形式为原码取反加一。对于1字节存储上看，0 ~ 127表示为0000 0000 ~ 0111 1111，-1 ~ -128表示为1111 1111 ~ 1000 0000。\n整数常量 十进制：不已0开头的包含0~9的数字。 八进制：必须已0开头的包含0~7的数字。 十六进制：必须已0x开头的包含0~9的数字与a~f的字母。 浮点类型 包含三类：\nfloat：单精度浮点数 double：双精度浮点数 long double：扩展双精度浮点数 浮点数存储方式 对于IEEE标准下的浮点数格式：单精度（32位，精度为6个数字）、双精度（64位，精度为15个数字），用二进制科学计数法进行存储，每个数均由三部分组成：\n符号（Sign） 指数（Exponent） 小数（Fraction） 二进制科学计数法可以表示为：\n$$ V = (-1)^S * F * 2^E $$\n举例来说，十进制的5.0，写成二进制是101.0，相当于$1.01×2^2$\n对于二进制，小数（F）部分一定以1开头，故将其省略；指数部分使用无符号数（unsigned）表示，故存储时，对其加上中间值（单精度是127、双精度是1023）\n指数E还可以再分成三种情况：\nE不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字F前加上第一位的1。 E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字F不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。 E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。 字符类型 字符类型占用1字节，C语言把字符当做小整形处理，故可以对字符进行加减操作。\n转移序列 主要分为字符转义序列和数字转义序列，由\\开始。\n字符转义序列表 名称 转义序列 名称 转义序列 报警（响铃） \\a 垂直制表符 \\v 回退 \\b 反斜杠 \\\\ 换页 \\f 问号 \\? 换行 \\n 单引号 \\' 回车 \\r 双引号 \\\u0026quot; 水平制表符 \\t 数字转移序列 直接显示数字所对应的字符\n八进制：由\\和跟随其后的最多含有三位的八进制数组成，不一定用0开头。 十六进制：由\\x和跟随其后的十六进制数组成。 字符读写 除printf与scanf之外，还可用getchar()与putchar(ch)函数。\n类型转换 算数转换 任意操作数为浮点类型：float -\u0026gt; double -\u0026gt; long double 两个操作数都不是浮点类型：int -\u0026gt; unsigned int -\u0026gt; long -\u0026gt; unsigned long 赋值转换 将存储空间窄的类型赋给宽的类型不会出现问题，反之会丢失精度甚至出现无意义的结果。\n强制类型转换 将类型强制进行转换，格式为：(类型名)表达式\n类型定义 可以使用类型定义可以让程序变得更加易读懂，使用关键字typedef进行：\ntypedef int Bool; Bool flag; sizeof运算符 返回指定类型值所需存储空间的大小，格式为：sizeof([类型名|表达式])。该运算符返回该类型所需空间的字节数，返回类型为size_t，该类型是一种无符号整形数，最安全的做法是转换为unsigned long类型。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/basic_types/","summary":"种类还挺多","title":"基本类型"},{"content":"一维数组 数组是含有多个同类型数据值得数据结构，数组的访问使用取下标进行索引，如a[0]，a[1]\u0026hellip;\n初始化 int a[5] = {1, 2, 3, 4, 5}; // 正常初始化 int a[5] = {1, 2, 3} // 后面自动补0值 int a[] = {1, 2, 3, 4, 5} // 默认数组长度为5 // C99初始化 int a[15] = {[2] = 2, [9] = 9, [13] = 13} // 指定位置初始化 获取数组长度 数组无法直接获取长度，通常使用sizeof(a) / sizeof(a[0])获取，由于该结果返回无符号整数，故为安全起见，可以对其进行强制类型转换。\n多维数组 数组可以有任意维度，常用的是二维数组，声明如下：\nint a[5][9];\n变长数组（C99） C99中允许使用变长数组，数组长度的声明可以使用变量进行。\nint n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n]; ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/array/","summary":"就是很多组数","title":"数组"},{"content":"函数定义，调用与声明 // 函数定义 返回类型 函数名 (形式参数) { 声明 语句 } // 函数调用 函数名 (形式参数); 函数的定义放在函数的调用之前，是没有问题的。很多情况下，函数的定义需要放在函数的调用之后，这时编译器并不知道函数的具体信息，将会默认函数返回为int，故在运行时会报错。\nC语言提供函数的隐式声明，可以先对函数进行声明，在后面进行函数的定义，格式为：返回类型 函数名 (形式参数);\n形式参数\u0026amp;实际参数 形式参数 形参出现在函数定义中 仅仅作为记号 实际参数 函数执行和调用函数期间 实际参数是通过值传递将值赋给形式参数的，故不会改变原参数的内容。\n程序终止 在main函数中执行return语句 调用exit()函数 ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/function/","summary":"很有内涵","title":"函数"},{"content":"局部变量 在函数体内声明的变量称为局部变量，形式参数与局部变量具有一样的性质。具有以下性质：\n自动存储期限：储存空间在包含该变量的函数被调用时自动分配，函数返回时回收分配的变量。 块作用域：在声明该变量的当前块内起效。 程序块是是由一组{}包含的语句。\n静态变量：使用static关键字修饰的变量将具有静态存储期限，该变量在程序执行期间拥有永久的存储单元。\n外部变量 外部变量声明在任何函数体。具有以下性质：\n静态存储期限：存储在外部变量中的值将永久保留下来。 文件作用域：外部变量在声明的点开始直到文件末尾都可以被访问。 作用域 用一个例子说明\nint i; // declaration 1 void f (int i) { // declaration 2 i = i; // 2 } void g (void) { int i = 2; // declaration 3 if (i \u0026gt; 0) { // 3 int i; // declaration 4 i = 3; // 4 } i = 4; // 3 } void h (void) { i = 5; // 1 } ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/scope/","summary":"不能出界呦","title":"作用域"},{"content":"指针变量 指针是存储内存地址的变量，指针的声明与普通变量的声明基本一致，但必须在变量名前放置*：\nint *p; // p仅能指向整数类型 double *q; // q仅能指向double类型 char *c; // c仅能指向字符类型 取地址运算符和间接寻址运算符 \\\\ \u0026amp;取地址运算符，获取变量的地址 \\\\ *间接寻址运算符，通过指针获取指针保存内存地址中的值 int i, *p; p = \u0026amp;i; printf(\u0026#34;%d\u0026#34;, *p); 指针作为参数或返回值 指针作为参数可以直接对传入参数进行修改。\nvoid add(int a. int b, int *sum) { *sum = a + b; return; } int main() { int a = 1, b = 2, sum; add(a, b, \u0026amp;sum); printf(\u0026#34;%d\u0026#34;, sum); } 函数也可以作为指针返回。但是绝不可以返回局部变量的指针。\nint *max(int *a, int *b) { return *a \u0026gt; *b ? a : b; } 指针与数组 数组在逻辑上是地址连续的相同数据类型，如果使用指针指向数组头，便可通过加减来操控指针访问数组内容：\nint a[10] = {0}; int *p; p = \u0026amp;a[0]; // p指向a[0] p += 1; // p指向a[1] 数组名可以用数组的名字作为指向数组第一个元素的指针，多维数组在内存中按照顺序排列，访问多维数组a[n][m]时可以使用*(a + n * row + m)实现。\n高级应用 动态分配内存 除动态数组外，还可用通过stdlib.h系统库函数进行内存动态分配：\nmalloc：分配内存块，但是不进行初始化，可以用于动态分配字符串与数组，函数原型：void *malloc(size_t size)，void指针可以指向任何类型的内存。 calloc：分配内存块，并对内存区域清零，函数原型：void *calloc(size_t nmemb, size_t size) realloc：调整之前分配的内存块大小 释放内存空间 malloc函数都会在堆中进行内存分配，如果使用完后没有释放该区域的内存，会导致内存泄漏。void free(void *p)函数用于释放指针指向的内存区域。被free过的指针将不指向任何内存空间，称为悬空指针。\n-\u0026gt;运算符 通常使用指针指向某一结构体，当需要获取其成员时，需要使用(*node).value，为了简洁表示，可以使用-\u0026gt;运算符，node -\u0026gt; value \u0026lt;==\u0026gt; (*node).value\n指向指针的指针 在使用链式结构时，通常使用指针的指针进行操作。\n指向函数的指针 double integrate(double (*f)(double), double a, double b); // (*f)就是函数的指针，其作为函数的参数之一 double integrate(double f(double), double a, double b); // 另一种写法 C语言将函数指针与指向数据的指针看做一致，这样就可以将函数指针存储在变量中（常见的是结构体中，很像面向对象）。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/pointer/","summary":"搞定它就搞定了C语言","title":"指针"},{"content":"字符串字面量 使用一对双引号括起来的字符序列。\n\u0026ldquo;Hello World\u0026rdquo;\n若字符串太长而无法放在一行内，可用\\字符结尾（本质是\\加回车符），但是新行的字符串必须从行开头开始，破坏了程序的易读性，所以通常使用两字符串拼接（\u0026ldquo;str1\u0026rdquo; \u0026ldquo;str2\u0026rdquo;）。\n字符串变量 C语言使用字符数组存储字符串字面量，并使用\\0字符作为结尾。\nchar str[12] = \u0026#34;Hello World\u0026#34;; char *p = \u0026#34;Hello World\u0026#34;; 由于指针可以指向数组，故指针可以指向一个字符串，但是这两种声明方式会有以下区别：\nstr[]可以任意修改存储在数组中的字符；p在试图修改字符串时将出现未定义行为。 str是数组名；p是变量，可以在程序执行时指向其他字符串。 字符串库 strcpy函数 char *strcpy(char *s1, const char *s2); 将字符串s2复制给字符串s1。\nstrlen函数 size_t strlen(const char *s); 返回字符串长度。\nstrcat函数 char *strcat(char *s1, const char *s2); 将s2的内容追加到s1末尾，并返回s1。\nstrcmp函数 int strcmp(const char *s1, const char *s2); 比较字符串s1与s2，跟进s1小于、等于或大于s2，返回一个小于、等于或大于0的数。\ns1小于s2满足下列任意条件：\ns1与s2在前i个字符一致，s1的第i+1个字符小于s2的第i+1个字符 s1与s2的所有字符一致，但是s1比s2短 字符串数组 char str[N][M] = { \u0026ldquo;str1\u0026rdquo;, \u0026ldquo;str2\u0026rdquo;, \u0026ldquo;str3\u0026rdquo;, \u0026ldquo;str4\u0026rdquo;, \u0026ldquo;str5\u0026rdquo; }\n这种方式会浪费内存，通常按照以下方式声明：\nchar *str[N] = { \u0026ldquo;str1\u0026rdquo;, \u0026ldquo;str2\u0026rdquo;, \u0026ldquo;str3\u0026rdquo;, \u0026ldquo;str4\u0026rdquo;, \u0026ldquo;str5\u0026rdquo; }\n命令行参数 命令行运行标准C程序的main函数存在两个参数，这两个参数分别是argc与argv:\nint main(int argc, char *argv[]) { } argc：命令行输入的参数个数 argv：参数按序组成的字符串数组 其中第一个参数是程序名称，第argv[argc]个元素是一个空指针。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/string/","summary":"不就是char数组吗？！","title":"字符串"},{"content":"工作原理 在对C/C++语言进行编译前根据预处理指令对程序进行修改，预处理指令是由#开头的命令，预处理指令可以令程序更加易读，经过预处理器的处理，程序的内容将被修改为编译器可以识别的代码。\n预处理指令 宏定义：#define指令定义一个宏，#undef指令删除一个宏定义 文件包含：#include指令导致一个指定文件的内容被包含到程序中 条件编译：#if、#ifdef、#ifndef、#elif、#else和#endif指令可以根据预处理器可以测试的条件来确定一段文本是否需要包含到程序中 预处理器的特性：\n以#开头 指令的符号间可以插入任意数量的空格或水平制表符 指令总在第一个换行符结束，如想在下一行继续，必须在末尾插入\\ 指令可以出现在程序中任意地方 注释可以与指令放在同一行 宏定义 简单的宏 #define 标识符 替换列表 通常使用宏定义来定义常量，不要对宏中插入任何多余的符号，否则他们会被作为替换列表的一部分。\n带参数的宏 #define 标识符(x1, x2, x3, ...) 替换列表\n标识符与括号间不允许有任何空格，否则括号将被识别为替换列表的内容。\n#define MAX(x, y) ((x) \u0026gt; (y) ? (x) : (y))\n将参数带上括号是有必要的，因为x与y很可能是表达式，而宏定义与函数调用不同，会产生意外的结果。\n#\u0026amp;##运算符 宏定义中可以包含两种特殊的运算符：\n#运算符：将参数完全看做字符串变量， #define PRINT_INT(n) printf(#n \u0026#34; = %d\u0026#34;, n) PRINT_INT(i/j); \u0026lt;==\u0026gt; printf(\u0026#34;i/j\u0026#34; \u0026#34; = %d\u0026#34;, i/j); ##运算符：将两个记号粘合起来，成为新的记号 #define MK_ID(n) i##n int MK_ID(1), MK_ID(2), MK_ID(3); \u0026lt;==\u0026gt; int i1, i2, i3; 通用属性 可以使用其他宏 只会替换完整的记号 定义作用范围为整个文件 不可以被重复定义 使用#undef取消定义 预定义宏 名称 描述 __LINE__ 被编译的文件的行号 __FILE__ 被编译的文件名 __DATE__ 编译日期(Mmm dd yyyy) __TIME__ 编译时间(hh:mm:ss) __STDC__ 编译器是否符合C89或C99 条件编译 #if 常量表达式 ... #elif 常量表达式 ... #else ... #endif 根据条件将使得对应内容生效。通常判断某个标识符是否定义，故存在#ifdef和#ifndef方便使用。\n其他预处理指令 #error 消息：输出编译时错误 #line n [文件名]：改变行编号方式 #pragma 记号：特殊编译功能 ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/preprocessor/","summary":"在高手手里会变得很强大","title":"预处理器"},{"content":"源文件 C程序可以分割成任意数量的源文件，源文件的扩展名为.c。\n头文件 源文件之间无法直接相互调用，这时，需要使用#include指令将需要共享的函数原型、宏定义以及类型定义等信息添加到源文件中。保存函数原型、宏定义以及类型定义的文件被称为头文件，通常使用.h作为后缀。\n#include指令 存在三种写法：\n#include\u0026lt;文件名\u0026gt;：用于属于C语言库内的头文件 #include \u0026quot;文件名\u0026quot;：用于所有其他的头文件 #include 记号：可以使用记号代替文件名，这样可以按条件进行文件包含 文件名尽量不要写绝对路径名，这样很难进行移植。\n若源文件包含头文件两次，那么可能产生编译错误，可以使用#ifdef和#endif指令来封闭文件内容：\n#ifndef BOOLEAN_H #define BOOLEAN_H #define TRUE 1 #define FALSE 0 typedef int BOOL; #endif BOOLEAN_H本质并无意义，只是用于标记头文件的，避免与其他宏冲突。\n构建多文件程序 makefile 编译大型程序时往往需要在命令行中输入大量的源文件信息，所以出现了makefile的概念，其包含了构建程序的必要信息。通过描述文件间的依赖性来构建程序。\njustify: justify.o word.o line.o gcc -o justify justify.o word.o line.o justify.o: justify.c word.h line.h gcc -c justify.c word.o: word.c word.h gcc -c word.c line.o: line.c line.h gcc -c line.c 每一组称为一条规则，每条规则的第一行给出目标文件，后面是其所有以来。第二行是待执行指令。当一个文件被修改，则依赖链上所有文件将被重新编译。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/project/","summary":"其实也很麻烦","title":"编写大型程序"},{"content":"结构变量 结构的成员具有不用的类型，声明如下：\nstruct { int id; char name[LEN + 1]; int age; } victor; 这里的声明格式与C语言中其他变量的声明格式一致，struct {\u0026hellip;}是变量类型，victor则是变量名。结构体的成员在内存中按序排列，访问成员时可以通过.操作符。\n初始化 struct { int id; char name[LEN + 1]; int age; } victor = {1, \u0026#34;zhou\u0026#34;, 25}; // 常用初始化 } victor = {.id = 1, .name = \u0026#34;zhou\u0026#34;, .age = 25}; // 指定初始化(C99) 结构标记的声明 结构标记可以对结构体进行命名：\nstruct person { int id; char name[LEN + 1]; int age; }; 之后使用结构标记声明变量\nstruct person victor; // 主要struct不能少 结构类型定义 可以通过typedef来进行定义\ntypedef struct { int id; char name[LEN + 1]; int age; } Person; 之后使用定义类型来声明变量\nPerson victor; // 不用带struct 联合 联合也是多个成员组成的，但是编译器只为占用空间最大的成员进行内存分配：\nunion { int i; double d; } u; struct { int i; double d; } s; 通常用于进行内存空间的节省。\n枚举 声明： enum {JAN, FEB, MAR, APR, ...} m1, m2; 编译器会将成员按序设为0, 1, 2, 3\u0026hellip;的值。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/struct_union_enum/","summary":"面向对象的雏形","title":"结构、联合与枚举"},{"content":"声明的格式： 声明说明符 声明符\n声明符给出了名字，声明说明符给出了变量或函数的性质\n声明说明符 分为3大类\n存储类型。分为四种：auto、static、extern和register。在声明中最多可以出现一种存储类型。且必须放在第一位。 类型限定符。两种：const和volatile。C99还定义了restrict。 类型说明符。void、char、shot、int、long、float、double、signed和unsigned。这些类型可以合理组合。 存储类型 变量具有以下性质\n存储期限：决定了为变量预留和内存被释放的时间。自动存储期限的变量在所属块被执行时获得内存单元，块终止时释放内存，变量将消失。静态存储期限的变量在程序运行期间占有同一个的存储单元。 作用域：作用域是可引用变量的那部分程序文本。分为块作用域（从声明到所在快末尾）和文件作用域（从声明到所在文件的末尾）。 连接：确定程序的不同部分可以共享此变量的范围。外部链接的变量可以被程序中的几个或全部文件共享。内部链接的变量只能属于单一文件。无连接的变量属于单独一个函数，且不能被共享。 默认情况下：\n块内部声明的变量具有：自动存储期限、块作用域且无链接 程序最外层声明的变量具有：静态存储期限、文件作用域和外部链接 int i; // 静态存储期限、文件作用域、外部链接 void f(void) { int j; // 自动存储期限、块作用域、无链接 } auto存储类型 就是块内部声明的变量，所以基本不用明确指明，因为编译器会自动为块内部变量添加auto关键字。\nstatic存储类型 static int i; // 静态存储期限、文件作用域、内部链接 void f(void) { static int j; // 静态存储期限、块作用域、无链接 } 与auto区别\n块内部static在程序执行前初始化一次，auto在每次出现时被初始化 递归时，auto都是新的内存地址，static是固定的一块内存地址 函数无法返回auto变量的指针，static的指针可以返回 extern存储类型 使多个源文件共享一个变量，仅提示编译器存在这一变量，并不会为其分配内存\nextern int i; // 静态存储期限、文件作用域、不确定 void f(void) { extern int j; // 静态存储期限、块作用域、不确定 } 变量的类型与之前被声明的连接类型一致\nregister存储类型 将变量存储在寄存器中，与auto存储类型一致，但是访问更迅速\n函数存储类型 extern int f(int i); // 外部链接 static int g(int i); // 内部链接 int h(int i); // 外部链接 类型限定符 volatile：告诉编译器该变量改变十分频繁，故编译器不能做任何优化；每次操作该值时，必须从内存中读取，也必须写到内存中，不得存入cache等地方 const：声明变量是只读的，在许多函数声明时将形参声明为const有利于程序 复杂的声明 声明的理解：\n始终从内到外读声明符。从名称开始一步一步向外解读 始终[]和()的优先级高于*。 int *(*x[10])(void)\n首先，x开始读，x跟着*与[]，[]的等级高于*，所以x是数组，是指针数组，指向不带参数的函数，函数返回的是int类型的指针。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/statement/","summary":"更加深层次的理解语言","title":"声明"},{"content":"位运算符 \u0026lt;\u0026lt;：左移运算符，低位补0，高位溢出 \u0026gt;\u0026gt;：右移运算符，无符号数和非负数高位补0，低位溢出，负数高位补1，低位溢出。 ~：按位取反 \u0026amp;：按位与 ^：按位异或 |：按位或 惯用法：\ni |= 1 \u0026lt;\u0026lt; j // 第j位设1 i \u0026amp;= ~(1 \u0026lt;\u0026lt; j) // 第j位清空 i \u0026amp; 1 \u0026lt;\u0026lt; j // 第j位是否为1 结构中的位域 特殊数据类型：\nstruct file_date { unsigned int day: 5; unsigned int month: 4; unsigned int year: 7; } ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/low_level_programming/","summary":"用对了可以更高效","title":"底层程序设计"}]