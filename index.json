[{"content":"编译与链接 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 编译器编译过程包括三个步骤：\n预处理：程序被交给 预处理器（Preprocessor） 。预处理器用于执行以#开头的指令，预处理指令用于对代码内容进行修改。 编译：修改后的代码由 编译器（Compiler） 处理。编译器讲代码编译为机器指令。 链接： 连接器（Linker） 将机器指令与其他附加代码进行整合，最终产生可执行文件。 目前GCC是最流行的C语言编译器，编译C文件可使用gcc -o output.o file.c命令。 ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/1_introduction/","summary":"运行Hello World","title":"简介"},{"content":" auto enum restrict unsigned break extern return void case float short volatile char for signed while const goto sizeof _Bool continue if static _Complex default inline struct _Imaginary do int switch double long typedef else register union 注意： 粗体字为C99关键字\n可以按照功能对关键字进行分类\n非常见：auto、register、volatile、goto 存储相关：const、extern、register、volatile、static、auto、signed、unsigned 数据类型：char、short、int、float、long、double、struct、union、enum、void 逻辑控制：if、else、for、while、do、break、continue、return、default、switch、case、goto 特殊用途：sizeof、typedef ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/2_key_word/","summary":"很关键","title":"关键字"},{"content":"输出函数 printf函数是用于显示“格式串”的内容，用法为：\nprintf(格式串, 表达式1, 表达式2, ...)\n格式串由普通字符和转换说明（conversion specification）组成。\n转换说明 结构 转换说明的结构为：%m.pX或%-m.pX，其中：\nm为最小字段宽度，其指定了需要显示的最少字符的数量，若字符数小于该值，则会在字符左边填充空格。若在m前放置-号，则会在字符串右边填充空格。 p为精度，对于不同的X，p的含义不同 d：代表十进制显示的个数，若不足，则在前面补充0 e：指数形式浮点数，p规定小数点后位数 f：小数点后位数 数据类型 整数：存储长度 + 进制 d、u、o、x：十进制、十进制无符号、八进制、十六进制 s、l：短整数、长整数 浮点数： f：以小数输出单、双精度浮点数 e：以指数输出单、双精度浮点数 g：以%f或%e中较短的输出宽度输出单、双精度实数 字符： c：单字符 s：字符串 输入函数 scanf函数根据特定的格式读取输入。\nscanf(格式串, \u0026amp;变量1, \u0026amp;变量2, ...)\n工作方式 当程序执行到scanf(\u0026quot;%d\u0026quot;, \u0026amp;a);时，程序向CPU发出指令，要求其先检测输入缓冲内有没有数据，本程序内输入缓冲内没有数据，CPU开始等待输入设备（键盘）向输入缓冲内输入数据，这里输入一个“2”，输入后按enter，此时2和换行符一并被输入设备写入输入缓冲，输入缓冲检测到有回车进来了，CPU开始执行读取指令，将2读取后将其从输入缓冲清除，从输入缓冲将数据“2”赋值给a，由于a是一个具体的地址空间变量，所以赋值结束后，CPU将a的值写入输入缓冲，对于笔记本电脑而言，a的保存输出设备就是电脑硬盘，所以电脑硬盘就是输出设备。\n对于不同数据类型处理方式：\n%d：对于整型数据的输入，也就是说”%d”类型的输入，scanf默认的分割符是所有的空白字符(空格，回车和指标符都行)。也就是说如果一个scanf函数中出现scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b) ，那么用任何一个空白字符来分隔两个整数a,b的值，变量a,b都可以接收到正确的输入。另外，要注意的是，scanf对于数字输入，会忽略输入数据项前面的空白字符。 %s：scanf对于字符串输入的处理和对整数类似，会忽略前导的空白字符，而且默认的分隔符是所有的空白字符。但是，要注意的是，由于C语言中，没有string类型，都是用char型数组来表示。因此，scanf会为每一个输入的字符串最后加一个‘\\0’ （NULL）。 %c：scanf在处理对字符数据的输入时，既不会忽略前导空白字符，默认也没有任何分隔字符。所有的字符，包括空白字符都会被当成输入字符。 C语言缓冲区 缓冲区的三种类型 全缓冲 在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是对磁盘文件的读写。\n行缓冲 scanf()函数的缓冲类型就是这个，在这种情况下，当在输入和输出中遇到换行符时，执行真正的I/O操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I/O操作。典型代表是键盘输入数据。\n不带缓冲 也就是不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来。\nC语言操作缓冲区 对于以下程序：\n#include \u0026lt;stdio.h\u0026gt; void main() { char a ,b ; printf(\u0026#34;请输入a和b的值：\u0026#34;); scanf(\u0026#34;%c%c\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;a=%c,b=%c\\n\u0026#34;,a,b); printf(\u0026#34;请输入a和b的值：\u0026#34;); scanf(\u0026#34;%c%c\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;a=%c,b=%c\\n\u0026#34;,a,b); } 输出如图： 分析：\n1~5：行程序正常执行； 6：程序走到这里，scanf检测到输入缓冲区没有字符，开始等待输入；我们输入了两个字符AB，这是我们一共在按键上依次按下”A”，”B”，“enter”，于是缓冲区现在有这三个字符；AB被分别分给了字符变量a，b；并且被清除了；于是缓冲区内就剩下了“enter”； 7：程序正常输出a,b值； 8：正常执行程序； 9：程序走到这里，scanf检测缓冲区内有字符，但是只有一个字符“enter”，不够再次分配两个变量的，所以程序让再输入一个字符；可是我们输入了两个字符，AB；程序结束后，a被赋值“enter”，b被赋值A，这时缓冲区不仅将会剩下一个B字符，还会剩下一个“enter”；这个缓冲区的内容会随着程序的结束而被消除，由于不操作了，所以我们感觉不到他俩的存在； 10：a，b再次被输出，a被输出了回车，所以换行了，a被输出了A； 程序结束； 缓冲区的刷新 下面几种情况将引起缓冲区刷新，也就是清空所有数据：\n缓冲区被写满 执行flush语句 执行endl语句 关闭文件 fflush(stdin)函数清除缓冲区\n#include \u0026lt;stdio.h\u0026gt; void main() { char a ,b ; printf(\u0026#34;请输入a和b的值：\u0026#34;); scanf(\u0026#34;%c%c\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;a=%c,b=%c\\n\u0026#34;,a,b); printf(\u0026#34;请输入a和b的值：\u0026#34;); fflush(stdin); //清除输入缓冲区； scanf(\u0026#34;%c%c\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;a=%c,b=%c\\n\u0026#34;,a,b); } 结果如下： ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/3_io/","summary":"输出你想要的格式","title":"输入输出"},{"content":"算数运算符 一元运算符 二元加法类运算符 二元乘法类运算符 + 一元正号运算符 + 加法运算符 * 乘法运算符 - 一元负号运算符 - 减法运算符 / 除法运算符 % 求余运算符 /运算符在进行整数运算时仅产生整数结果 /与%在进行附属操作时结果难以确定，如果两个操作数中有一个是负数，那么结果可以向上或向下取整（-9 / 7 = -1 or -2），取余也与实现有关（-9 % 7 = -2 or 5），在C99中，除法总是向0截取（-9 / 7 = -1），i % j的正负与i相同（-9 % 7 = -2） 为解决表达式中包含多个运算符时产生的二义性问题，运算符引入优先级和结核性：\n运算符优先级：运算符按照优先级从高到低的次序进行计算。+与-的优先级低于*与/ 结核性：在优先级一致情况下，按照结核性依次计算。 赋值运算符 C语言将=看做是运算符之一，v = e产生的结果是e。\n符合赋值：+=、-=、*=、\\=\u0026hellip;\n自增/自减运算符 自增（++）、自减（\u0026ndash;）运算符既可以作为前缀运算符也可作为后缀运算符。\n注：如i++ + ++i这种情况会导致undefined behavior，千万不要写出这种语句。 逗号运算符 ,运算符用于连接多个表达式，并返回最末尾表达式的值。\n运算符表 优先级 名称 符号 结合性 1 数组取下值 [] 左 1 函数调用 () 左 1 取结构体和联合的成员 . -\u0026gt; 左 1 自增（后缀） ++ 左 1 自减（后缀） -- 左 2 自增（前缀） ++ 右 2 自减（前缀） -- 右 2 取地址 \u0026amp; 右 2 间接寻址 * 右 2 一元正号 + 右 2 一元负号 - 右 2 按位求反 ~ 右 2 逻辑非 ! 右 2 计算空间 sizeof 右 3 强制类型转换 () 右 4 乘法类运算符 * / % 左 5 加法类运算符 + - 左 6 位移 \u0026lt;\u0026lt; \u0026gt;\u0026gt; 左 7 关系 \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 左 8 判等 == != 左 9 按位与 \u0026amp; 左 10 按位异或 ^ 左 11 按位或 ` ` 12 逻辑与 \u0026amp;\u0026amp; 左 13 逻辑或 ` 14 条件 ?: 右 15 赋值 = *= /= %= += -= \u0026lt;\u0026lt;= \u0026gt;\u0026gt;= \u0026amp;= ^= != 右 16 逗号 , 左 ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/4_operator/","summary":"原来加减乘除还有这么多门道","title":"运算符"},{"content":"选择语句 逻辑表达式 关系运算符（\u0026lt;、\u0026gt;、\u0026gt;=、\u0026lt;=）判等运算符（==、!=）逻辑运算符（\u0026amp;\u0026amp;、||）连接的表达式，结果返回真（1）或假（0），C语言中==号仅能用于基本类型上的判断，字符串判等需要使用strcmp()函数。\n注：逻辑运算符拥有短路效应。\nif语句 if (bool) { /* statements */ } else if (bool) { /* statements */ } else { /* statements */ } else语句总是与上一个距自己最近的if语句相匹配。\n三元条件表达式 s1 ? s2 : s3;\ns1成立，则s2，否则s3。\nswitch语句 switch(表达式) { case 常量表达式 : /* statements */ ... case 常量表达式 : /* statements */ default : /* statements */ } 一旦传入表达式符合某一常量表达式会将后面所有语句执行，不要忘记在使用break跳出switch。\n循环语句 while语句 while (bool) { /* statements */ } do语句 do { /* statements */ } while (bool); for语句 for (表达式1; 表达式2; 表达式3) { \\\\ 表达式2返回bool类型 /* statements */ } 执行顺序：表达式1 -\u0026gt; 表达式2 -\u0026gt; 语句 -\u0026gt; 表达式3\n退出循环语句 break语句：吧程序控制从包含该语句的最内侧while，do、for或switch语句中转移出来。 continue语句：直接将程序控制转至循环体末尾。 goto语句：直接将程序跳转至程序任意位置。 标识符 : /* statements */ goto 标识符; ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/5_control_statements/","summary":"基本操作","title":"控制语句"},{"content":"整数类型 整数类型根据存储数据大小可以分为长整型（long）与短整型（short），根据是否存储负数分为有符号型（signed）与无符号型（unsigned），故整数类型共有6种：\nshort (int) unsigned short (int) int unsigned int long (int) unsigned long (int) 根据机器不同，取值范围也不同，以下是详细对比： 16位机\n类型 最大 最小 大小（字节） short -32768 32767 2 unsigned short 0 65535 2 int -32768 32767 2 unsigned int 0 65535 2 long -2147483648 2147483647 4 unsigned long 0 4294967295 4 32位机\n类型 最大 最小 大小（字节） short -32768 32767 2 unsigned short 0 65535 2 int -2147483648 2147483647 4 unsigned int 0 4294967295 4 long -2147483648 2147483647 4 unsigned long 0 4294967295 4 64位机\n类型 最大 最小 大小（字节） short -32768 32767 2 unsigned short 0 65535 2 int -2147483648 2147483647 4 unsigned int 0 4294967295 4 long -9223372036854775808 9223372036854775807 8 unsigned long 0 18446744073709551615 8 有符号型整数在计算机中均已补码的形式存储，其中最高位表示符号位，正数的补码为其源码，负数的补码形式为原码取反加一。对于1字节存储上看，0 ~ 127表示为0000 0000 ~ 0111 1111，-1 ~ -128表示为1111 1111 ~ 1000 0000。\n整数常量 十进制：不已0开头的包含0~9的数字。 八进制：必须已0开头的包含0~7的数字。 十六进制：必须已0x开头的包含0~9的数字与a~f的字母。 浮点类型 包含三类：\nfloat：单精度浮点数 double：双精度浮点数 long double：扩展双精度浮点数 浮点数存储方式 对于IEEE标准下的浮点数格式：单精度（32位，精度为6个数字）、双精度（64位，精度为15个数字），用二进制科学计数法进行存储，每个数均由三部分组成：\n符号（Sign） 指数（Exponent） 小数（Fraction） 二进制科学计数法可以表示为：\n$$ V = (-1)^S * F * 2^E $$\n举例来说，十进制的5.0，写成二进制是101.0，相当于$1.01×2^2$\n对于二进制，小数（F）部分一定以1开头，故将其省略；指数部分使用无符号数（unsigned）表示，故存储时，对其加上中间值（单精度是127、双精度是1023）\n指数E还可以再分成三种情况：\nE不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字F前加上第一位的1。 E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字F不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。 E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。 字符类型 字符类型占用1字节，C语言把字符当做小整形处理，故可以对字符进行加减操作。\n转移序列 主要分为字符转义序列和数字转义序列，由\\开始。\n字符转义序列表 名称 转义序列 名称 转义序列 报警（响铃） \\a 垂直制表符 \\v 回退 \\b 反斜杠 \\\\ 换页 \\f 问号 \\? 换行 \\n 单引号 \\' 回车 \\r 双引号 \\\u0026quot; 水平制表符 \\t 数字转移序列 直接显示数字所对应的字符\n八进制：由\\和跟随其后的最多含有三位的八进制数组成，不一定用0开头。 十六进制：由\\x和跟随其后的十六进制数组成。 字符读写 除printf与scanf之外，还可用getchar()与putchar(ch)函数。\n类型转换 算数转换 任意操作数为浮点类型：float -\u0026gt; double -\u0026gt; long double 两个操作数都不是浮点类型：int -\u0026gt; unsigned int -\u0026gt; long -\u0026gt; unsigned long 赋值转换 将存储空间窄的类型赋给宽的类型不会出现问题，反之会丢失精度甚至出现无意义的结果。\n强制类型转换 将类型强制进行转换，格式为：(类型名)表达式\n类型定义 可以使用类型定义可以让程序变得更加易读懂，使用关键字typedef进行：\ntypedef int Bool; Bool flag; sizeof运算符 返回指定类型值所需存储空间的大小，格式为：sizeof([类型名|表达式])。该运算符返回该类型所需空间的字节数，返回类型为size_t，该类型是一种无符号整形数，最安全的做法是转换为unsigned long类型。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/6_basic_types/","summary":"种类还挺多","title":"基本类型"},{"content":"一维数组 数组是含有多个同类型数据值得数据结构，数组的访问使用取下标进行索引，如a[0]，a[1]\u0026hellip;\n初始化 int a[5] = {1, 2, 3, 4, 5}; // 正常初始化 int a[5] = {1, 2, 3} // 后面自动补0值 int a[] = {1, 2, 3, 4, 5} // 默认数组长度为5 // C99初始化 int a[15] = {[2] = 2, [9] = 9, [13] = 13} // 指定位置初始化 获取数组长度 数组无法直接获取长度，通常使用sizeof(a) / sizeof(a[0])获取，由于该结果返回无符号整数，故为安全起见，可以对其进行强制类型转换。\n多维数组 数组可以有任意维度，常用的是二维数组，声明如下：\nint a[5][9];\n变长数组（C99） C99中允许使用变长数组，数组长度的声明可以使用变量进行。\nint n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n]; ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/7_array/","summary":"就是很多组数","title":"数组"},{"content":"函数定义，调用与声明 // 函数定义 返回类型 函数名 (形式参数) { 声明 语句 } // 函数调用 函数名 (形式参数); 函数的定义放在函数的调用之前，是没有问题的。很多情况下，函数的定义需要放在函数的调用之后，这时编译器并不知道函数的具体信息，将会默认函数返回为int，故在运行时会报错。\nC语言提供函数的隐式声明，可以先对函数进行声明，在后面进行函数的定义，格式为：返回类型 函数名 (形式参数);\n形式参数\u0026amp;实际参数 形式参数 形参出现在函数定义中 仅仅作为记号 实际参数 函数执行和调用函数期间 实际参数是通过值传递将值赋给形式参数的，故不会改变原参数的内容。\n程序终止 在main函数中执行return语句 调用exit()函数 ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/8_function/","summary":"很有内涵","title":"函数"},{"content":"局部变量 在函数体内声明的变量称为局部变量，形式参数与局部变量具有一样的性质。具有以下性质：\n自动存储期限：储存空间在包含该变量的函数被调用时自动分配，函数返回时回收分配的变量。 块作用域：在声明该变量的当前块内起效。 程序块是是由一组{}包含的语句。\n静态变量：使用static关键字修饰的变量将具有静态存储期限，该变量在程序执行期间拥有永久的存储单元。\n外部变量 外部变量声明在任何函数体。具有以下性质：\n静态存储期限：存储在外部变量中的值将永久保留下来。 文件作用域：外部变量在声明的点开始直到文件末尾都可以被访问。 作用域 用一个例子说明\nint i; // declaration 1 void f (int i) { // declaration 2 i = i; // 2 } void g (void) { int i = 2; // declaration 3 if (i \u0026gt; 0) { // 3 int i; // declaration 4 i = 3; // 4 } i = 4; // 3 } void h (void) { i = 5; // 1 } ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/9_scope/","summary":"不能出界呦","title":"作用域"},{"content":"指针变量 指针是存储内存地址的变量，指针的声明与普通变量的声明基本一致，但必须在变量名前放置*：\nint *p; // p仅能指向整数类型 double *q; // q仅能指向double类型 char *c; // c仅能指向字符类型 取地址运算符和间接寻址运算符 \\\\ \u0026amp;取地址运算符，获取变量的地址 \\\\ *间接寻址运算符，通过指针获取指针保存内存地址中的值 int i, *p; p = \u0026amp;i; printf(\u0026#34;%d\u0026#34;, *p); 指针作为参数或返回值 指针作为参数可以直接对传入参数进行修改。\nvoid add(int a. int b, int *sum) { *sum = a + b; return; } int main() { int a = 1, b = 2, sum; add(a, b, \u0026amp;sum); printf(\u0026#34;%d\u0026#34;, sum); } 函数也可以作为指针返回。但是绝不可以返回局部变量的指针。\nint *max(int *a, int *b) { return *a \u0026gt; *b ? a : b; } 指针与数组 数组在逻辑上是地址连续的相同数据类型，如果使用指针指向数组头，便可通过加减来操控指针访问数组内容：\nint a[10] = {0}; int *p; p = \u0026amp;a[0]; // p指向a[0] p += 1; // p指向a[1] 数组名可以用数组的名字作为指向数组第一个元素的指针，多维数组在内存中按照顺序排列，访问多维数组a[n][m]时可以使用*(a + n * row + m)实现。\n高级应用 动态分配内存 除动态数组外，还可用通过stdlib.h系统库函数进行内存动态分配：\nmalloc：分配内存块，但是不进行初始化，可以用于动态分配字符串与数组，函数原型：void *malloc(size_t size)，void指针可以指向任何类型的内存。 calloc：分配内存块，并对内存区域清零，函数原型：void *calloc(size_t nmemb, size_t size) realloc：调整之前分配的内存块大小 释放内存空间 malloc函数都会在堆中进行内存分配，如果使用完后没有释放该区域的内存，会导致内存泄漏。void free(void *p)函数用于释放指针指向的内存区域。被free过的指针将不指向任何内存空间，称为悬空指针。\n-\u0026gt;运算符 通常使用指针指向某一结构体，当需要获取其成员时，需要使用(*node).value，为了简洁表示，可以使用-\u0026gt;运算符，node -\u0026gt; value \u0026lt;==\u0026gt; (*node).value\n指向指针的指针 在使用链式结构时，通常使用指针的指针进行操作。\n指向函数的指针 double integrate(double (*f)(double), double a, double b); // (*f)就是函数的指针，其作为函数的参数之一 double integrate(double f(double), double a, double b); // 另一种写法 C语言将函数指针与指向数据的指针看做一致，这样就可以将函数指针存储在变量中（常见的是结构体中，很像面向对象）。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/10_pointer/","summary":"搞定它就搞定了C语言","title":"指针"},{"content":"字符串字面量 使用一对双引号括起来的字符序列。\n\u0026ldquo;Hello World\u0026rdquo;\n若字符串太长而无法放在一行内，可用\\字符结尾（本质是\\加回车符），但是新行的字符串必须从行开头开始，破坏了程序的易读性，所以通常使用两字符串拼接（\u0026ldquo;str1\u0026rdquo; \u0026ldquo;str2\u0026rdquo;）。\n字符串变量 C语言使用字符数组存储字符串字面量，并使用\\0字符作为结尾。\nchar str[12] = \u0026#34;Hello World\u0026#34;; char *p = \u0026#34;Hello World\u0026#34;; 由于指针可以指向数组，故指针可以指向一个字符串，但是这两种声明方式会有以下区别：\nstr[]可以任意修改存储在数组中的字符；p在试图修改字符串时将出现未定义行为。 str是数组名；p是变量，可以在程序执行时指向其他字符串。 字符串库 strcpy函数 char *strcpy(char *s1, const char *s2); 将字符串s2复制给字符串s1。\nstrlen函数 size_t strlen(const char *s); 返回字符串长度。\nstrcat函数 char *strcat(char *s1, const char *s2); 将s2的内容追加到s1末尾，并返回s1。\nstrcmp函数 int strcmp(const char *s1, const char *s2); 比较字符串s1与s2，跟进s1小于、等于或大于s2，返回一个小于、等于或大于0的数。\ns1小于s2满足下列任意条件：\ns1与s2在前i个字符一致，s1的第i+1个字符小于s2的第i+1个字符 s1与s2的所有字符一致，但是s1比s2短 字符串数组 char str[N][M] = { \u0026ldquo;str1\u0026rdquo;, \u0026ldquo;str2\u0026rdquo;, \u0026ldquo;str3\u0026rdquo;, \u0026ldquo;str4\u0026rdquo;, \u0026ldquo;str5\u0026rdquo; }\n这种方式会浪费内存，通常按照以下方式声明：\nchar *str[N] = { \u0026ldquo;str1\u0026rdquo;, \u0026ldquo;str2\u0026rdquo;, \u0026ldquo;str3\u0026rdquo;, \u0026ldquo;str4\u0026rdquo;, \u0026ldquo;str5\u0026rdquo; }\n命令行参数 命令行运行标准C程序的main函数存在两个参数，这两个参数分别是argc与argv:\nint main(int argc, char *argv[]) { } argc：命令行输入的参数个数 argv：参数按序组成的字符串数组 其中第一个参数是程序名称，第argv[argc]个元素是一个空指针。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/11_string/","summary":"不就是char数组吗？！","title":"字符串"},{"content":"工作原理 在对C/C++语言进行编译前根据预处理指令对程序进行修改，预处理指令是由#开头的命令，预处理指令可以令程序更加易读，经过预处理器的处理，程序的内容将被修改为编译器可以识别的代码。\n预处理指令 宏定义：#define指令定义一个宏，#undef指令删除一个宏定义 文件包含：#include指令导致一个指定文件的内容被包含到程序中 条件编译：#if、#ifdef、#ifndef、#elif、#else和#endif指令可以根据预处理器可以测试的条件来确定一段文本是否需要包含到程序中 预处理器的特性：\n以#开头 指令的符号间可以插入任意数量的空格或水平制表符 指令总在第一个换行符结束，如想在下一行继续，必须在末尾插入\\ 指令可以出现在程序中任意地方 注释可以与指令放在同一行 宏定义 简单的宏 #define 标识符 替换列表 通常使用宏定义来定义常量，不要对宏中插入任何多余的符号，否则他们会被作为替换列表的一部分。\n带参数的宏 #define 标识符(x1, x2, x3, ...) 替换列表\n标识符与括号间不允许有任何空格，否则括号将被识别为替换列表的内容。\n#define MAX(x, y) ((x) \u0026gt; (y) ? (x) : (y))\n将参数带上括号是有必要的，因为x与y很可能是表达式，而宏定义与函数调用不同，会产生意外的结果。\n#\u0026amp;##运算符 宏定义中可以包含两种特殊的运算符：\n#运算符：将参数完全看做字符串变量， #define PRINT_INT(n) printf(#n \u0026#34; = %d\u0026#34;, n) PRINT_INT(i/j); \u0026lt;==\u0026gt; printf(\u0026#34;i/j\u0026#34; \u0026#34; = %d\u0026#34;, i/j); ##运算符：将两个记号粘合起来，成为新的记号 #define MK_ID(n) i##n int MK_ID(1), MK_ID(2), MK_ID(3); \u0026lt;==\u0026gt; int i1, i2, i3; 通用属性 可以使用其他宏 只会替换完整的记号 定义作用范围为整个文件 不可以被重复定义 使用#undef取消定义 预定义宏 名称 描述 __LINE__ 被编译的文件的行号 __FILE__ 被编译的文件名 __DATE__ 编译日期(Mmm dd yyyy) __TIME__ 编译时间(hh:mm:ss) __STDC__ 编译器是否符合C89或C99 条件编译 #if 常量表达式 ... #elif 常量表达式 ... #else ... #endif 根据条件将使得对应内容生效。通常判断某个标识符是否定义，故存在#ifdef和#ifndef方便使用。\n其他预处理指令 #error 消息：输出编译时错误 #line n [文件名]：改变行编号方式 #pragma 记号：特殊编译功能 ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/12_preprocessor/","summary":"在高手手里会变得很强大","title":"预处理器"},{"content":"源文件 C程序可以分割成任意数量的源文件，源文件的扩展名为.c。\n头文件 源文件之间无法直接相互调用，这时，需要使用#include指令将需要共享的函数原型、宏定义以及类型定义等信息添加到源文件中。保存函数原型、宏定义以及类型定义的文件被称为头文件，通常使用.h作为后缀。\n#include指令 存在三种写法：\n#include\u0026lt;文件名\u0026gt;：用于属于C语言库内的头文件 #include \u0026quot;文件名\u0026quot;：用于所有其他的头文件 #include 记号：可以使用记号代替文件名，这样可以按条件进行文件包含 文件名尽量不要写绝对路径名，这样很难进行移植。\n若源文件包含头文件两次，那么可能产生编译错误，可以使用#ifdef和#endif指令来封闭文件内容：\n#ifndef BOOLEAN_H #define BOOLEAN_H #define TRUE 1 #define FALSE 0 typedef int BOOL; #endif BOOLEAN_H本质并无意义，只是用于标记头文件的，避免与其他宏冲突。\n构建多文件程序 makefile 编译大型程序时往往需要在命令行中输入大量的源文件信息，所以出现了makefile的概念，其包含了构建程序的必要信息。通过描述文件间的依赖性来构建程序。\njustify: justify.o word.o line.o gcc -o justify justify.o word.o line.o justify.o: justify.c word.h line.h gcc -c justify.c word.o: word.c word.h gcc -c word.c line.o: line.c line.h gcc -c line.c 每一组称为一条规则，每条规则的第一行给出目标文件，后面是其所有以来。第二行是待执行指令。当一个文件被修改，则依赖链上所有文件将被重新编译。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/13_project/","summary":"其实也很麻烦","title":"编写大型程序"},{"content":"结构变量 结构的成员具有不用的类型，声明如下：\nstruct { int id; char name[LEN + 1]; int age; } victor; 这里的声明格式与C语言中其他变量的声明格式一致，struct {\u0026hellip;}是变量类型，victor则是变量名。结构体的成员在内存中按序排列，访问成员时可以通过.操作符。\n初始化 struct { int id; char name[LEN + 1]; int age; } victor = {1, \u0026#34;zhou\u0026#34;, 25}; // 常用初始化 } victor = {.id = 1, .name = \u0026#34;zhou\u0026#34;, .age = 25}; // 指定初始化(C99) 结构标记的声明 结构标记可以对结构体进行命名：\nstruct person { int id; char name[LEN + 1]; int age; }; 之后使用结构标记声明变量\nstruct person victor; // 主要struct不能少 结构类型定义 可以通过typedef来进行定义\ntypedef struct { int id; char name[LEN + 1]; int age; } Person; 之后使用定义类型来声明变量\nPerson victor; // 不用带struct 联合 联合也是多个成员组成的，但是编译器只为占用空间最大的成员进行内存分配：\nunion { int i; double d; } u; struct { int i; double d; } s; 通常用于进行内存空间的节省。\n枚举 声明： enum {JAN, FEB, MAR, APR, ...} m1, m2; 编译器会将成员按序设为0, 1, 2, 3\u0026hellip;的值。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/14_struct_union_enum/","summary":"面向对象的雏形","title":"结构、联合与枚举"},{"content":"声明的格式： 声明说明符 声明符\n声明符给出了名字，声明说明符给出了变量或函数的性质\n声明说明符 分为3大类\n存储类型。分为四种：auto、static、extern和register。在声明中最多可以出现一种存储类型。且必须放在第一位。 类型限定符。两种：const和volatile。C99还定义了restrict。 类型说明符。void、char、shot、int、long、float、double、signed和unsigned。这些类型可以合理组合。 存储类型 变量具有以下性质\n存储期限：决定了为变量预留和内存被释放的时间。自动存储期限的变量在所属块被执行时获得内存单元，块终止时释放内存，变量将消失。静态存储期限的变量在程序运行期间占有同一个的存储单元。 作用域：作用域是可引用变量的那部分程序文本。分为块作用域（从声明到所在快末尾）和文件作用域（从声明到所在文件的末尾）。 连接：确定程序的不同部分可以共享此变量的范围。外部链接的变量可以被程序中的几个或全部文件共享。内部链接的变量只能属于单一文件。无连接的变量属于单独一个函数，且不能被共享。 默认情况下：\n块内部声明的变量具有：自动存储期限、块作用域且无链接 程序最外层声明的变量具有：静态存储期限、文件作用域和外部链接 int i; // 静态存储期限、文件作用域、外部链接 void f(void) { int j; // 自动存储期限、块作用域、无链接 } auto存储类型 就是块内部声明的变量，所以基本不用明确指明，因为编译器会自动为块内部变量添加auto关键字。\nstatic存储类型 static int i; // 静态存储期限、文件作用域、内部链接 void f(void) { static int j; // 静态存储期限、块作用域、无链接 } 与auto区别\n块内部static在程序执行前初始化一次，auto在每次出现时被初始化 递归时，auto都是新的内存地址，static是固定的一块内存地址 函数无法返回auto变量的指针，static的指针可以返回 extern存储类型 使多个源文件共享一个变量，仅提示编译器存在这一变量，并不会为其分配内存\nextern int i; // 静态存储期限、文件作用域、不确定 void f(void) { extern int j; // 静态存储期限、块作用域、不确定 } 变量的类型与之前被声明的连接类型一致\nregister存储类型 将变量存储在寄存器中，与auto存储类型一致，但是访问更迅速\n函数存储类型 extern int f(int i); // 外部链接 static int g(int i); // 内部链接 int h(int i); // 外部链接 类型限定符 volatile：告诉编译器该变量改变十分频繁，故编译器不能做任何优化；每次操作该值时，必须从内存中读取，也必须写到内存中，不得存入cache等地方 const：声明变量是只读的，在许多函数声明时将形参声明为const有利于程序 复杂的声明 声明的理解：\n始终从内到外读声明符。从名称开始一步一步向外解读 始终[]和()的优先级高于*。 int *(*x[10])(void)\n首先，x开始读，x跟着*与[]，[]的等级高于*，所以x是数组，是指针数组，指向不带参数的函数，函数返回的是int类型的指针。\n","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/15_statement/","summary":"更加深层次的理解语言","title":"声明"},{"content":"位运算符 \u0026lt;\u0026lt;：左移运算符，低位补0，高位溢出 \u0026gt;\u0026gt;：右移运算符，无符号数和非负数高位补0，低位溢出，负数高位补1，低位溢出。 ~：按位取反 \u0026amp;：按位与 ^：按位异或 |：按位或 惯用法：\ni |= 1 \u0026lt;\u0026lt; j // 第j位设1 i \u0026amp;= ~(1 \u0026lt;\u0026lt; j) // 第j位清空 i \u0026amp; 1 \u0026lt;\u0026lt; j // 第j位是否为1 结构中的位域 特殊数据类型：\nstruct file_date { unsigned int day: 5; unsigned int month: 4; unsigned int year: 7; } ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/c/16_low_level_programming/","summary":"用对了可以更高效","title":"底层程序设计"},{"content":"基本语法规则 变量使用${}方式取值，但是在IF控制语句中是直接使用变量名， 指令(参数 1 参数 2 \u0026hellip;)参数使用括弧括起，参数之间使用空格或分号分开， ADD_EXECUTABLE(hello main.c func.c)\nADD_EXECUTABLE(hello main.c;func.c)\n指令是大小写无关的，参数和变量是大小写相关的。但推荐全部使用大写指令。 指令 project 语法 PROJECT(projectnema [CXX] [C] [Java])\n作用 指定工程名和工程语言，并隐式定义了两个全局变量：\u0026lt;projectname\u0026gt;_SOURCE_DIR和\u0026lt;projectname\u0026gt;_BINARY_DIR。同时cmake系统也帮助我们预定义了 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR变量，他们的值分别跟前者一致。\nset 语法 SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])\n作用 显式的定义变量。\n对于单个文件，可以使用SET(SRC_LIST main.c)，如果有多个源文件，也可以定义成：SET(SRC_LIST main.c t1.c t2.c)。\nmessage 语法 MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] \u0026quot;message to display\u0026quot; ...)\n作用 向终端输出用户定义的信息。包含三种类型：\nSEND_ERROR：产生错误，生成过程被跳过， SATUS：输出前缀为-的信息， FATAL_ERROR：立即终止所有cmake过程。 add_executable 语法 ADD_EXECUTABLE(executablename ${SRC_LIST})\n作用 生成一个文件名为executablename的可执行文件，相关的源文件是SRC_LIST中定义的源文件列表。\n也可以忽略掉SRC_LIST列表中的源文件后缀，比如可以写成ADD_EXECUTABLE(t1 main)，cmake会自动的在本目录查找main.c或者main.cpp等，但最好不要偷这个懒，以免这个目录确实存在main.c和main。\nadd_subdirectory 语法 ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])\n作用 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL参数的含义是将这个目录从编译过程中排除。\ninstall(TARGETS) 语法 INSTALL(TARGETS targets... [[ARCHIVE|LIBRARY|RUNTIME] [DESTINATION \u0026lt;dir\u0026gt;] [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT \u0026lt;component\u0026gt;] [OPTIONAL] ] [...] ) 用法 安装的内容可以包括目标二进制、动态库、静态库。\n参数中的TARGETS后面跟的就是我们通过ADD_EXECUTABLE或者ADD_LIBRARY定义的目标文件，可能是可执行二进制、动态库、静态库。目标类型也就相对应的有三种：\nARCHIVE：特指静态库， LIBRARY：特指动态库， RUNTIME：特指可执行目标二进制。 DESTINATION定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候CMAKE_INSTALL_PREFIX将无效。\n例：\n/** * 可执行二进制myrun安装到 ${CMAKE_INSTALL_PREFIX}/bin 目录 * 动态库libmylib安装到 ${CMAKE_INSTALL_PREFIX}/lib 目录 * 静态库libmystaticlib安装到 ${CMAKE_INSTALL_PREFIX}/libstatic 目录 */ INSTALL(TARGETS myrun mylib mystaticlib RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION libstatic ) ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/cmake/1_grammer/","summary":"CMake的所有用法","title":"语法"},{"content":"基础 变量和基本类型 unsigned char 8bit，表示范围0到255，若超出赋值，则取该值对256求模后的值 C++字符串字面值由编译器自动在末尾加上空字符 直接初始化效率高于复制初始化 直接初始化：int ival(1024); 复制初始化：int ival = 1024; 变量定义分配存储空间，声明仅向程序表明变量类型和名字，不分配存储空间 extern关键字，仅声明变量而不定义 extern int i; 默认情况下，访问级别：struct的成员为public，而class的成员private 箭头操作符 (*p).foo; // 获得p指向对象的成员变量foo p-\u0026gt;foo; // 与上面等价 数组 sizeof：对对象求内存大小（对象数据类型的大小） const char *words[] = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;}; size_t st1 = sizeof(words); size_t st2 = sizeof(char *); // 相当于string cout \u0026lt;\u0026lt; st1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; st2 \u0026lt;\u0026lt; endl; size_t size = st1 / st2; cout \u0026lt;\u0026lt; size \u0026lt;\u0026lt; endl; 输出： 16 8 2 strlen：求字符串的实际长度，从开始到遇到第一个\\0 char a[10] = {\u0026#39;\\0\u0026#39;}; char b[10] = \u0026#34;123\u0026#34;; cout \u0026lt;\u0026lt; strlen(a) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; strlen(b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(a) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sizeof(b) \u0026lt;\u0026lt; endl; 输出： 0 3 10 10 指针和引用 指针 可能的取值： 保存一个对象的地址 保存某对象后面的对象 0值 引用 绑定对象的别名，必须被初始化 int ival = 1024; int \u0026amp;refVal = ival; 作用在引用上的所有操作实际上都是该引用绑定的对象上 const引用是指向const对象的引用 swap函数，交换实参的值，需要将形参定义为引用类型： void swap(int \u0026amp;v1, int \u0026amp;v2) { int tmp = v2; v2 = v1; v1 = tmp; } 调用： swap(i, j) 举例 int ival = 1024; int *pi = 0; // 初始化为0值 int *pi2 = \u0026amp;ival; // 初始化为ival的地址 int *pi3; // 未初始化 pi = pi2; // pi和pi2保存同一对象的地址 注：\u0026amp; 取地址操作符 // 指针 \u0026amp; 引用 int ival = 1024; int \u0026amp;refVal = ival; cout \u0026lt;\u0026lt; refVal \u0026lt;\u0026lt; endl; int *p = \u0026amp;refVal; // p保存ival的地址，*p保存值 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; int *p2 = p; cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt; endl; 输出： 1024 0x7ffeefbff618 1024 0x7ffeefbff618 1024 下标和指针 int ia[] = {0, 2, 4, 6, 8}; int *p = \u0026amp;ia[2]; // p指向数组下标为2的元素 int j = p[1]; // p[1]等价于*(p+1)，p[1]也就是ia[3] int k = p[-1]; // p[-2]也就是ia[0] 顺序容器 sequential container 三种顺序容器类型： vector（可变长数组，可扩容） list（双向链表） deque（基于双端队列，用链表连接数组） 注：list和deque提供了首部插入push_front和尾部插入push_back，首部删除pop_front和尾部删除pop_back 关联容器 associative container 与顺序容器差别 通过key存储和读取元素 三种关联容器类型： map #include \u0026lt;map\u0026gt; map\u0026lt;string,int\u0026gt; word_count; word_count[\u0026#34;Anna\u0026#34;] = 1; cout \u0026lt;\u0026lt; word_count[\u0026#34;Anna\u0026#34;] \u0026lt;\u0026lt; endl; set multimap和multiset 键可以多次出现 继承 virtual是基类期待派生类重新定义的，派生类动态绑定，注：成员函数默认为：非虚函数 构造函数后加冒号，是：成员变量的初始化 在成员函数的形参后面写上=0，则成员函数为纯虚函数，包含纯虚函数的类不能被实例化 const修饰成员函数，防止成员变量被修改 virtual double net_price(std::size_t n) const { return n * price; } ","permalink":"https://victor-zhc.github.io/posts/computer/c_cpp/cpp/1_grammer/","summary":"C++关键语法","title":"语法"},{"content":"队列接口 接口形式 interface Queue\u0026lt;E\u0026gt;{ void add(E element); E remove(); int size(); } 实现途径 循环列表 链表 集合接口与迭代器接口 集合接口形式 interface Collection\u0026lt;E\u0026gt;{ // 向集合添加元素，如果结果改变了集合，返回true boolean add(E element); // 向集合添加other中的所有元素，如果结果改变了集合，返回true boolean addAll(Collection\u0026lt;? extends E\u0026gt; other); // 返回用于依次访问集合中元素的对象 Iterator\u0026lt;E\u0026gt; iterator(); // 返回当前集合的元素个数 int size(); // 当集合中不存在元素，返回true boolean isEmpty(); // 如果集合中包含一个与obj相同的对象，返回true boolean contains(Object obj); // 如果集合中包含other集合的所有元素，返回true boolean containsAll(Collection\u0026lt;?\u0026gt; other); // 从集合中删除与obj相同的元素，如有对象被删除，返回true boolean remove(Object obj); // 从集合中删除other集合的所有元素，如改变了集合内容，返回true boolean removeAll(Collection\u0026lt;?\u0026gt; other); // 删除集合中的所有元素 void clear(); // 从集合中删除所有与other集合中元素不同的元素，如改变了集合内容，返回true（相交） boolean retainAll(Collection\u0026lt;?\u0026gt; other); // 返回这个集合的对象数组 Object[] toArray(); // 返回这个集合的对象数组，如果arrayToFill足够大，就将元素填入这个数组中，剩余空位 //填null；否则，分配一个新数组，成员类型与arrayToFill一样，长度等于集合长度，并填 //入元素 \u0026lt;T\u0026gt; T[] toArray(T[] arrayToFill); } 迭代器接口形式 interface Iterator\u0026lt;E\u0026gt;{ // 查找下一个元素，与当前指向元素密切相关 E next(); // 判断当前指向的元素后面是否还存在元素 boolean hasNext(); // 移除当前指向的元素，必须配合next函数使用 void remove(); } for each也可用于遍历集合内元素，本质是带有迭代器的循环；可以使用在任何实现了Iterable接口的对象，该接口仅包含一个方法： Iterator iterator() 元素被访问的顺序取决于集合类型，ArrayList被迭代时按照索引从0开始，HashSet被迭代时按照随机的顺序 具体集合 1. 链表 删除元素和在某位置插入元素代价很小 Java中一般是双向链表 在尾部插入元素依靠链表的add方法 在中间插入元素依靠Iterator的add方法 LinkedList采用双向链表实现 2. 数组列表 适合使用get和set方式随机访问元素 ArrayList是非同步的，执行速度快（初始大小为10，按1.5倍速度扩容） Vector类是同步的，不同线程可以安全访问（+capacityIncrement扩容 or 2倍） Stack继承于Vector，实现LIFO，是同步的 3. 散列集 HashMap，线程不安全，参考HashMap HashSet是基于HashMap实现的，线程不安全，不接受重复对象，不支持get(int)获取指定位置元素 散列表（Hashtable）由链表数组实现，每个链表是被称为一个桶（bucket），线程安全 ConcurrentHashMap采用了分段锁的设计，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。默认情况下，可允许16个线程并发无阻塞的操作集合对象。 4. 树集 TreeSet与散列集相似，但是它是有序集合，所有对象都被排序（调用集合元素的compareTo方法） 实现方式是红-黑树，基于comparator比较key放在树的左边还是右边 5. 对象比较 在有序集合中，对象的比较是通过Comparable接口实现 接口中有一个int compareTo(T other)方法。对于a.compareTo(b)来说，当a与b相等，将返回0；a在b之前，返回负值；a在b之后，返回正值 当无法定义Comparable接口时，可以利用Comparator对象实现和Comparable一样的功能，并将其传给TreeSet 6. 队列与双端队列 可以在队列头部和尾部同时添加和删除元素 由ArrayDeque和LinkedList实现 7. 优先级队列 按照任意顺序插入，但是按照优先级的顺序查找 利用堆（heap）实现，本质是一个可以自我调节的二叉树，优先级最高的元素总是在根部 可以实现Comparable接口 8. 映射表 map是键/值对存储的，依靠key来进行索引 两个通用实现，HashMap和TreeMap HashMap对键进行散列后存储，TreeMap对键进行比较后有序的存储 键必须是唯一的 keySet()函数返回的不是HashSet或TreeSet，而是另一个实现了Set的对象 9. 专用集与映射表类 WeakHashMap：当对键的引用只有散列表有引用时，就可以删除键/值对，通过WeakReference对象实现 LinkedHashSet\u0026amp;LinkedHashMap：所有对象被双链表连接，每次在get和put时，条目都会从当前位置删除，挪到链表末尾，可以用于实现“最近最少使用”原则 EnumSet：枚举类型元素集的高效实现，只有静态工厂方法 IdentityHashMap：不适用hashCode函数进行散列，而是通过System.identityHashCode实现，对hash的比较是通过“==”而不是“equals” ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_basics/1_collection/","summary":"设计之美","title":"Collection集合类"},{"content":"类声明 实现CharSequence、Comparable、Serializable接口 final类型，不可变 public final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { } 变量声明 /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 length函数 public int length() { return value.length; } isEmpty函数 public boolean isEmpty() { return value.length == 0; } charAt函数 public char charAt(int index) { if ((index \u0026lt; 0) || (index \u0026gt;= value.length)) { throw new StringIndexOutOfBoundsException(index); } return value[index]; } getChars函数 将字符串中字符复制到目的字符数组中\npublic void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) { if (srcBegin \u0026lt; 0) { throw new StringIndexOutOfBoundsException(srcBegin); } if (srcEnd \u0026gt; value.length) { throw new StringIndexOutOfBoundsException(srcEnd); } if (srcBegin \u0026gt; srcEnd) { throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); } System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); } equals函数 顺序对比，$O(n)$的时间代价\npublic boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 对于字符串而言 ==比较两个对象在内存中的首地址 equals()比较字符串中所包含内容是否相等 contentEquals函数 对比内容是否一致\npublic boolean contentEquals(CharSequence cs) { // Argument is a StringBuffer, StringBuilder if (cs instanceof AbstractStringBuilder) { if (cs instanceof StringBuffer) { synchronized(cs) { return nonSyncContentEquals((AbstractStringBuilder)cs); } } else { return nonSyncContentEquals((AbstractStringBuilder)cs); } } // Argument is a String if (cs instanceof String) { return equals(cs); } // Argument is a generic CharSequence char v1[] = value; int n = v1.length; if (n != cs.length()) { return false; } for (int i = 0; i \u0026lt; n; i++) { if (v1[i] != cs.charAt(i)) { return false; } } return true; } private boolean nonSyncContentEquals(AbstractStringBuilder sb) { char v1[] = value; char v2[] = sb.getValue(); int n = v1.length; if (n != sb.length()) { return false; } for (int i = 0; i \u0026lt; n; i++) { if (v1[i] != v2[i]) { return false; } } return true; } compareTo函数 从左到右比较，返回ASCII码的差，如果全部一致，返回长度差\npublic int compareTo(String anotherString) { int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k \u0026lt; lim) { char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) { return c1 - c2; } k++; } return len1 - len2; } hashCode函数 $$S_031^{(n-1)} + S_131^{(n-2)} + \u0026hellip; + S_{n-1}*31^0$$ 选用31作为因子的原因\n31是质数 可以被优化为$31*i=(i\u0026laquo;5)-i$ 冲突概率小 不容易溢出 public int hashCode() { int h = hash; if (h == 0 \u0026amp;\u0026amp; value.length \u0026gt; 0) { char val[] = value; for (int i = 0; i \u0026lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } indexOf函数 搜索是否存在相同子序列\nstatic int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) { if (fromIndex \u0026gt;= sourceCount) { return (targetCount == 0 ? sourceCount : -1); } if (fromIndex \u0026lt; 0) { fromIndex = 0; } if (targetCount == 0) { return fromIndex; } char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i \u0026lt;= max; i++) { /* Look for first character. */ if (source[i] != first) { while (++i \u0026lt;= max \u0026amp;\u0026amp; source[i] != first); } /* Found first character, now look at the rest of v2 */ if (i \u0026lt;= max) { int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j \u0026lt; end \u0026amp;\u0026amp; source[j] == target[k]; j++, k++); if (j == end) { /* Found whole string. */ return i - sourceOffset; } } } return -1; } substring函数 public String substring(int beginIndex, int endIndex) { if (beginIndex \u0026lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } if (endIndex \u0026gt; value.length) { throw new StringIndexOutOfBoundsException(endIndex); } int subLen = endIndex - beginIndex; if (subLen \u0026lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return ((beginIndex == 0) \u0026amp;\u0026amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); } concat函数 字符串拼接\npublic String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true); } join函数 通过delimiter将字符串拼接起来\npublic static String join(CharSequence delimiter, Iterable\u0026lt;? extends CharSequence\u0026gt; elements) { Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) { joiner.add(cs); } return joiner.toString(); } trim函数 去掉String两边的空格\npublic String trim() { int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st \u0026lt; len) \u0026amp;\u0026amp; (val[st] \u0026lt;= \u0026#39; \u0026#39;)) { st++; } while ((st \u0026lt; len) \u0026amp;\u0026amp; (val[len - 1] \u0026lt;= \u0026#39; \u0026#39;)) { len--; } return ((st \u0026gt; 0) || (len \u0026lt; value.length)) ? substring(st, len) : this; } ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_source/1_string/","summary":"简单实用","title":"String源码"},{"content":"类声明 继承AbstractMap 实现Map、Cloneable、Serializable接口 public class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable { } 节点实现 hash与key不可变 hash冲突时，使用开散列 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; } 变量声明 // 默认容量为16 static final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // aka 16 // 最大扩容为1\u0026lt;\u0026lt;30 static final int MAXIMUM_CAPACITY = 1 \u0026lt;\u0026lt; 30; // 加载参数，默认0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 散列冲突时，从链表转到红黑树的阈值 static final int TREEIFY_THRESHOLD = 8; // resize操作后，红黑树将改变，当节点数小于阈值时，变回链表 static final int UNTREEIFY_THRESHOLD = 6; // map容量大小超过该阈值，才会对冲突散列转换成红黑树 static final int MIN_TREEIFY_CAPACITY = 64; // map具体实现形式为数组（桶） transient Node\u0026lt;K,V\u0026gt;[] table; // 插入实体大小 transient int size; // 被操作的次数 transient int modCount; // 超过阈值的时候map将被resize int threshold; hash函数 高位不变，低位与高位进行与操作,这样做可以实现了高地位更加均匀地混到一起。\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 0001 0101 1010 1110 1011 0111 1010 1011(363771819)\n0000 0000 0000 0000 0001 0101 1010 1110(5550) XOR\n===========================================\n0001 0101 1010 1110 1010 0010 0000 0101(363766277)\ntableSizeFor函数 返回距离cap最近的2的幂，在初始化map时使用\nstatic final int tableSizeFor(int cap) { // 防止cap本身就是2的幂的情况 int n = cap - 1; // 假设n为01... // 右移1位为001...，或操作后变为011... n |= n \u0026gt;\u0026gt;\u0026gt; 1; // 右移2位为00011...，或操作后变为01111... n |= n \u0026gt;\u0026gt;\u0026gt; 2; n |= n \u0026gt;\u0026gt;\u0026gt; 4; n |= n \u0026gt;\u0026gt;\u0026gt; 8; n |= n \u0026gt;\u0026gt;\u0026gt; 16; // 最后n+1得距离cap最近的2的幂 return (n \u0026lt; 0) ? 1 : (n \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } resize函数 初始化map或使map大小翻倍，所有数据要么还位于原来的index，或位于新多出来的位置中\nfinal Node\u0026lt;K,V\u0026gt;[] resize() { Node\u0026lt;K,V\u0026gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap \u0026gt; 0) { // 当原大小比最大容积大，直接返回 if (oldCap \u0026gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 否则大小翻倍 else if ((newCap = oldCap \u0026lt;\u0026lt; 1) \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; oldCap \u0026gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr \u0026lt;\u0026lt; 1; // double threshold } // 初始化容积为原阈值 else if (oldThr \u0026gt; 0) newCap = oldThr; // 使用默认值 else { newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } 更改阈值大小 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; // 申请新表，大小为newCap Node\u0026lt;K,V\u0026gt;[] newTab = (Node\u0026lt;K,V\u0026gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { // 遍历原表 for (int j = 0; j \u0026lt; oldCap; ++j) { Node\u0026lt;K,V\u0026gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; // 实例为hash最后一位，将他直接散列到新表 if (e.next == null) newTab[e.hash \u0026amp; (newCap - 1)] = e; // 当e是树节点时，将树拆开 else if (e instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)e).split(this, newTab, j, oldCap); // 说明实例在哈希冲突链中，将链拆开 else { Node\u0026lt;K,V\u0026gt; loHead = null, loTail = null; Node\u0026lt;K,V\u0026gt; hiHead = null, hiTail = null; Node\u0026lt;K,V\u0026gt; next; do { next = e.next; if ((e.hash \u0026amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } put函数 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; // 若table未初始化，初始化table if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 若hash值没有冲突，新建Node\u0026lt;K,V\u0026gt;元素，将实例放入数组中 if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 解决冲突 else { Node\u0026lt;K,V\u0026gt; e; K k; // key与冲突对象的key相同时，直接update if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; // 当节点是红黑树节点时，将p插入红黑树 else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); // 开散列 else { // 遍历链表 for (int binCount = 0; ; ++binCount) { // 添加到链表尾部，如果超过阈值，变为红黑树 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 与开散列中的实例key一致，update开散列实例 if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; // 真正设置value if (!onlyIfAbsent || oldValue == null) e.value = value; // 回调函数 afterNodeAccess(e); return oldValue; } } // resize函数 ++modCount; if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } get函数 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node\u0026lt;K,V\u0026gt; getNode(int hash, Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n; K k; // 当hash位置存在实例时 if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; hash]) != null) { // 如果第一个实例命中，返回第一个 if (first.hash == hash \u0026amp;\u0026amp; ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; // 依次遍历后续 if ((e = first.next) != null) { // 如果是红黑树，将节点变为TreeNode if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } containsKey函数 public boolean containsKey(Object key) { return getNode(hash(key), key) != null; } remove函数 public V remove(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } final Node\u0026lt;K,V\u0026gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, index; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (p = tab[index = (n - 1) \u0026amp; hash]) != null) { Node\u0026lt;K,V\u0026gt; node = null, e; K k; V v; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { // 如果是TreeNode，获取TreeNode if (p instanceof TreeNode) node = ((TreeNode\u0026lt;K,V\u0026gt;)p).getTreeNode(hash, key); // 否则查找链表 else { do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } // 如果找到节点，将其删除 if (node != null \u0026amp;\u0026amp; (!matchValue || (v = node.value) == value || (value != null \u0026amp;\u0026amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } TreeNode 实现为红黑树\nstatic final class TreeNode\u0026lt;K,V\u0026gt; extends LinkedHashMap.Entry\u0026lt;K,V\u0026gt; { TreeNode\u0026lt;K,V\u0026gt; parent; // red-black tree links TreeNode\u0026lt;K,V\u0026gt; left; TreeNode\u0026lt;K,V\u0026gt; right; TreeNode\u0026lt;K,V\u0026gt; prev; // needed to unlink next upon deletion boolean red; /** * Ensures that the given root is the first node of its bin. */ static \u0026lt;K,V\u0026gt; void moveRootToFront(Node\u0026lt;K,V\u0026gt;[] tab, TreeNode\u0026lt;K,V\u0026gt; root) { int n; if (root != null \u0026amp;\u0026amp; tab != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0) { int index = (n - 1) \u0026amp; root.hash; TreeNode\u0026lt;K,V\u0026gt; first = (TreeNode\u0026lt;K,V\u0026gt;)tab[index]; if (root != first) { Node\u0026lt;K,V\u0026gt; rn; tab[index] = root; TreeNode\u0026lt;K,V\u0026gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode\u0026lt;K,V\u0026gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; } assert checkInvariants(root); } } /** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. */ final TreeNode\u0026lt;K,V\u0026gt; find(int h, Object k, Class\u0026lt;?\u0026gt; kc) { TreeNode\u0026lt;K,V\u0026gt; p = this; do { int ph, dir; K pk; TreeNode\u0026lt;K,V\u0026gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) \u0026gt; h) p = pl; else if (ph \u0026lt; h) p = pr; else if ((pk = p.key) == k || (k != null \u0026amp;\u0026amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) \u0026amp;\u0026amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir \u0026lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; } while (p != null); return null; } /** * Calls find for root node. */ final TreeNode\u0026lt;K,V\u0026gt; getTreeNode(int h, Object k) { return ((parent != null) ? root() : this).find(h, k, null); } /** * Tie-breaking utility for ordering insertions when equal * hashCodes and non-comparable. We don\u0026#39;t require a total * order, just a consistent insertion rule to maintain * equivalence across rebalancings. Tie-breaking further than * necessary simplifies testing a bit. */ static int tieBreakOrder(Object a, Object b) { int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) \u0026lt;= System.identityHashCode(b) ? -1 : 1); return d; } /** * Forms tree of the nodes linked from this node. * @return root of tree */ final void treeify(Node\u0026lt;K,V\u0026gt;[] tab) { TreeNode\u0026lt;K,V\u0026gt; root = null; for (TreeNode\u0026lt;K,V\u0026gt; x = this, next; x != null; x = next) { next = (TreeNode\u0026lt;K,V\u0026gt;)x.next; x.left = x.right = null; if (root == null) { x.parent = null; x.red = false; root = x; } else { K k = x.key; int h = x.hash; Class\u0026lt;?\u0026gt; kc = null; for (TreeNode\u0026lt;K,V\u0026gt; p = root;;) { int dir, ph; K pk = p.key; if ((ph = p.hash) \u0026gt; h) dir = -1; else if (ph \u0026lt; h) dir = 1; else if ((kc == null \u0026amp;\u0026amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode\u0026lt;K,V\u0026gt; xp = p; if ((p = (dir \u0026lt;= 0) ? p.left : p.right) == null) { x.parent = xp; if (dir \u0026lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; } } } } moveRootToFront(tab, root); } /** * Returns a list of non-TreeNodes replacing those linked from * this node. */ final Node\u0026lt;K,V\u0026gt; untreeify(HashMap\u0026lt;K,V\u0026gt; map) { Node\u0026lt;K,V\u0026gt; hd = null, tl = null; for (Node\u0026lt;K,V\u0026gt; q = this; q != null; q = q.next) { Node\u0026lt;K,V\u0026gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; } return hd; } /** * Tree version of putVal. */ final TreeNode\u0026lt;K,V\u0026gt; putTreeVal(HashMap\u0026lt;K,V\u0026gt; map, Node\u0026lt;K,V\u0026gt;[] tab, int h, K k, V v) { Class\u0026lt;?\u0026gt; kc = null; boolean searched = false; TreeNode\u0026lt;K,V\u0026gt; root = (parent != null) ? root() : this; for (TreeNode\u0026lt;K,V\u0026gt; p = root;;) { int dir, ph; K pk; if ((ph = p.hash) \u0026gt; h) dir = -1; else if (ph \u0026lt; h) dir = 1; else if ((pk = p.key) == k || (k != null \u0026amp;\u0026amp; k.equals(pk))) return p; else if ((kc == null \u0026amp;\u0026amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) { if (!searched) { TreeNode\u0026lt;K,V\u0026gt; q, ch; searched = true; if (((ch = p.left) != null \u0026amp;\u0026amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null \u0026amp;\u0026amp; (q = ch.find(h, k, kc)) != null)) return q; } dir = tieBreakOrder(k, pk); } TreeNode\u0026lt;K,V\u0026gt; xp = p; if ((p = (dir \u0026lt;= 0) ? p.left : p.right) == null) { Node\u0026lt;K,V\u0026gt; xpn = xp.next; TreeNode\u0026lt;K,V\u0026gt; x = map.newTreeNode(h, k, v, xpn); if (dir \u0026lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode\u0026lt;K,V\u0026gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; } } } /** * Removes the given node, that must be present before this call. * This is messier than typical red-black deletion code because we * cannot swap the contents of an interior node with a leaf * successor that is pinned by \u0026#34;next\u0026#34; pointers that are accessible * independently during traversal. So instead we swap the tree * linkages. If the current tree appears to have too few nodes, * the bin is converted back to a plain bin. (The test triggers * somewhere between 2 and 6 nodes, depending on tree structure). */ final void removeTreeNode(HashMap\u0026lt;K,V\u0026gt; map, Node\u0026lt;K,V\u0026gt;[] tab, boolean movable) { int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) \u0026amp; hash; TreeNode\u0026lt;K,V\u0026gt; first = (TreeNode\u0026lt;K,V\u0026gt;)tab[index], root = first, rl; TreeNode\u0026lt;K,V\u0026gt; succ = (TreeNode\u0026lt;K,V\u0026gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) { tab[index] = first.untreeify(map); // too small return; } TreeNode\u0026lt;K,V\u0026gt; p = this, pl = left, pr = right, replacement; if (pl != null \u0026amp;\u0026amp; pr != null) { TreeNode\u0026lt;K,V\u0026gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode\u0026lt;K,V\u0026gt; sr = s.right; TreeNode\u0026lt;K,V\u0026gt; pp = p.parent; if (s == pr) { // p was s\u0026#39;s direct parent p.parent = s; s.right = p; } else { TreeNode\u0026lt;K,V\u0026gt; sp = s.parent; if ((p.parent = sp) != null) { if (s == sp.left) sp.left = p; else sp.right = p; } if ((s.right = pr) != null) pr.parent = s; } p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; } else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) { TreeNode\u0026lt;K,V\u0026gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; } TreeNode\u0026lt;K,V\u0026gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) { // detach TreeNode\u0026lt;K,V\u0026gt; pp = p.parent; p.parent = null; if (pp != null) { if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; } } if (movable) moveRootToFront(tab, r); } /** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */ final void split(HashMap\u0026lt;K,V\u0026gt; map, Node\u0026lt;K,V\u0026gt;[] tab, int index, int bit) { TreeNode\u0026lt;K,V\u0026gt; b = this; // Relink into lo and hi lists, preserving order TreeNode\u0026lt;K,V\u0026gt; loHead = null, loTail = null; TreeNode\u0026lt;K,V\u0026gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode\u0026lt;K,V\u0026gt; e = b, next; e != null; e = next) { next = (TreeNode\u0026lt;K,V\u0026gt;)e.next; e.next = null; if ((e.hash \u0026amp; bit) == 0) { if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; } else { if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; } } if (loHead != null) { if (lc \u0026lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else { tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); } } if (hiHead != null) { if (hc \u0026lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else { tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); } } } /* ------------------------------------------------------------ */ // Red-black tree methods, all adapted from CLR // 左旋 static \u0026lt;K,V\u0026gt; TreeNode\u0026lt;K,V\u0026gt; rotateLeft(TreeNode\u0026lt;K,V\u0026gt; root, TreeNode\u0026lt;K,V\u0026gt; p) { TreeNode\u0026lt;K,V\u0026gt; r, pp, rl; if (p != null \u0026amp;\u0026amp; (r = p.right) != null) { if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; } return root; } // 右旋 static \u0026lt;K,V\u0026gt; TreeNode\u0026lt;K,V\u0026gt; rotateRight(TreeNode\u0026lt;K,V\u0026gt; root, TreeNode\u0026lt;K,V\u0026gt; p) { TreeNode\u0026lt;K,V\u0026gt; l, pp, lr; if (p != null \u0026amp;\u0026amp; (l = p.left) != null) { if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; } return root; } // 插入 static \u0026lt;K,V\u0026gt; TreeNode\u0026lt;K,V\u0026gt; balanceInsertion(TreeNode\u0026lt;K,V\u0026gt; root, TreeNode\u0026lt;K,V\u0026gt; x) { x.red = true; for (TreeNode\u0026lt;K,V\u0026gt; xp, xpp, xppl, xppr;;) { if ((xp = x.parent) == null) { x.red = false; return x; } else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) { if ((xppr = xpp.right) != null \u0026amp;\u0026amp; xppr.red) { xppr.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.right) { root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateRight(root, xpp); } } } } else { if (xppl != null \u0026amp;\u0026amp; xppl.red) { xppl.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.left) { root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateLeft(root, xpp); } } } } } } // 删除 static \u0026lt;K,V\u0026gt; TreeNode\u0026lt;K,V\u0026gt; balanceDeletion(TreeNode\u0026lt;K,V\u0026gt; root, TreeNode\u0026lt;K,V\u0026gt; x) { for (TreeNode\u0026lt;K,V\u0026gt; xp, xpl, xpr;;) { if (x == null || x == root) return root; else if ((xp = x.parent) == null) { x.red = false; return x; } else if (x.red) { x.red = false; return root; } else if ((xpl = xp.left) == x) { if ((xpr = xp.right) != null \u0026amp;\u0026amp; xpr.red) { xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr == null) x = xp; else { TreeNode\u0026lt;K,V\u0026gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) \u0026amp;\u0026amp; (sl == null || !sl.red)) { xpr.red = true; x = xp; } else { if (sr == null || !sr.red) { if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr != null) { xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; } if (xp != null) { xp.red = false; root = rotateLeft(root, xp); } x = root; } } } else { // symmetric if (xpl != null \u0026amp;\u0026amp; xpl.red) { xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl == null) x = xp; else { TreeNode\u0026lt;K,V\u0026gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) \u0026amp;\u0026amp; (sr == null || !sr.red)) { xpl.red = true; x = xp; } else { if (sl == null || !sl.red) { if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl != null) { xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; } if (xp != null) { xp.red = false; root = rotateRight(root, xp); } x = root; } } } } } /** * Recursive invariant check（循环不变量检查） */ static \u0026lt;K,V\u0026gt; boolean checkInvariants(TreeNode\u0026lt;K,V\u0026gt; t) { TreeNode\u0026lt;K,V\u0026gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode\u0026lt;K,V\u0026gt;)t.next; if (tb != null \u0026amp;\u0026amp; tb.next != t) return false; if (tn != null \u0026amp;\u0026amp; tn.prev != t) return false; if (tp != null \u0026amp;\u0026amp; t != tp.left \u0026amp;\u0026amp; t != tp.right) return false; if (tl != null \u0026amp;\u0026amp; (tl.parent != t || tl.hash \u0026gt; t.hash)) return false; if (tr != null \u0026amp;\u0026amp; (tr.parent != t || tr.hash \u0026lt; t.hash)) return false; if (t.red \u0026amp;\u0026amp; tl != null \u0026amp;\u0026amp; tl.red \u0026amp;\u0026amp; tr != null \u0026amp;\u0026amp; tr.red) return false; if (tl != null \u0026amp;\u0026amp; !checkInvariants(tl)) return false; if (tr != null \u0026amp;\u0026amp; !checkInvariants(tr)) return false; return true; } } ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_source/2_hash_map/","summary":"竟有如此多细节","title":"HashMap源码"},{"content":" 程序计数器（Program Counter Register） 是一块较小的内存空间，是当前线程所执行的字节码的行号指示器 线程私有的 执行Java方法时，记录字节码指令的地址；执行Native方法时，值为空（Undefined） 是唯一在Java虚拟机规范中没有定义OutOfMemoryError情况的区域 Java虚拟机栈（Java Virtual Machine Stacks） 生命周期与线程相同 线程私有的 每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储： 局部变量表 以Slot为最小单位 能存放：boolean、byte、char、short、int、float、long、double、reference（对象引用）、returnAddress（指向一条字节码指令的地址）类型 long、double将占用2个Slot 操作数栈 与局部变量表相似，但是不是依靠索引访问，而是通过入栈、出栈来访问 动态链接 方法出口 当线程请求的栈深度大于虚拟机允许的深度时，将抛出StackOverFlowError异常 当虚拟机栈在动态扩展时无法申请到足够的空间时，将会抛出OutOfMemoryError异常 本地方法栈（Native Method Stack） 线程私有的 执行Native方法所用 对数据结构没有具体要求 会抛出StackOverFlowError异常、OutOfMemoryError异常 Java堆（Heap） 虚拟机启动时被创建 被所有线程共享 几乎所有的对象实例在堆中分配内存 垃圾收集器管理的主要区域 逻辑上连续的空间 如无内存完成实例分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常 方法区（Method Area） 线程共享的内存区域 加载类信息、常量、静态变量、即时编译器编译后的代码等数据 此区域的垃圾回收行为很少出现 无法满足内存分配需求时，将抛出OutOfMemoryError异常 运行时常量池（Runtime Constant Pool） 是方法区的一部分 用于存放编译器生成的各种字面量和符号引用 常量池无法申请到内存时会抛出OutOfMemoryError异常 直接内存（Direct Memory） 不是虚拟机运行时数据区的一部分 NIO类引入了基于通道（Channel）与缓冲区（Buffer）的I/O方式，使用Native方法直接在堆外内存直接分配内存 当所有内存与直接内存的总和大于物理内存时，将抛出OutOfMemoryError异常 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/1_run-time_data_areas/","summary":"原来它们都在这些地方","title":"运行时数据区域"},{"content":" 当遇到一条new指令时，首先检查指令的参数能否在常量池中定位到一个类的符号引用 对象的大小在类加载完成后便可完全确定，之后从Java堆中将内存划分出来即可 如果Java堆中的内存是规整的（占用的内存和空闲内存分离），中间使用指针作为分界线，分配内存即将指针挪动对象大小的距离，称为指针碰撞（Bump the Pointer） 如果Java堆中的内存不是规整的，则需要一个列表来记录哪些内存块是可用的，分配内存时通过列表去查找可用的内存，这种分配方式被称为空闲列表（Free List） 不同方式取决与GC是否带有压缩整理的功能 在并发的情况下，内存分配可能出现错误，解决方案有两种 分配内存的动作进行同步处理 把内存分配的动作按照线程划分在不同的空间之中进行，每个线程预先在Java堆中分配一小块内存，成为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），当TLAB用完需要分配新的TLAB时，才需要同步锁定 将内存空间初始化为0值 对对象头进行设置（哪个类的实例、哈希码，GC分代年龄等信息） 执行方法，对对象进行初始化 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/2_create_object/","summary":"对象竟然是这么来的","title":"对象创建"},{"content":"对象头（Header） 第一部分（Mark Word）包括存储对象时的运行时数据：哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等 第二部分是类型指针，指向类元数据的指针，数组对象还需记录数组的长度信息（对象访问定位-直接指针访问的情况） 实例数据（Instance Data） 存储对象在程序代码中所定义的各种类型的字段内容 存储顺序受虚拟机分配策略（FieldsAllocationStyle）和字段在Java源码中定义的顺序影响 对齐填充（Padding） 起到占位符的作用（Java中要求对象大小必须是8字节的整数倍） ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/3_object_memory_layout/","summary":"对象原来长这样","title":"对象内存布局"},{"content":"Java程序需要通过栈上的reference数据来操作堆上的具体对象。对象的访问方式分为两种\n句柄访问 Java堆中将划分出一块内存作为句柄池，reference存储对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息\n优点：\n当对象移动的时候（垃圾回收的时候移动很普遍），这样只需要改变句柄中的指针，但是栈中的指针不需要变化，因为栈中存储的是句柄的地址 缺点：\n需要进行二次定位，寻找两次指针，开销相对于更大一些 直接指针访问 reference存储的直接就是对象的地址\n优点：\n速度快，不需要和句柄一样指针定位的开销 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/4_object_access_location/","summary":"对象竟然是这样找到的","title":"对象访问定位"},{"content":"引用计数器算法 为对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；引用失效时，计数器减1；当计数器为0时，对象就是不可被引用的\n优点是简单，判定效率高 缺点是难以解决对象之间循环引用的问题 可达性分析算法 通过一系列称为GC Roots的对象作为起点，当GC Roots到某个对象不可达时，判定此对象是废弃的，从GC Roots到对象所经过的路径被称为引用链（Reference Chain）\n可以作为GC Roots的对象包括：\n虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中Native方法引用的对象 引用 强引用（Strong Reference） 普遍存在，就是类似Object obj = new Object()的引用，只要强引用还在，垃圾回收器就不会回收被引用的对象\n软引用（Soft Reference） 描述之前还有但并非必须的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收\n弱引用（Weak Reference） 被弱引用关联的对象只能生存到下一次垃圾收集发生之前\n虚引用（Phantom Reference） 对象是否有虚引用与其生存时间无任何关系，设置虚引用的目的仅是在对象被系统回收时收到一个系统通知\n对象死亡 当对象不可达时，垃圾回收器还需要判定对象是否有必要执行finalize()方法 ，当判定对象有必要执行finalize()方法时，那么对象将暂时放在一个F-Queue队列之中，并在一个低优先级线程中执行finalize()，但finalize()方法不一定能够运行结束\npublic class EscapeGC { public static EscapeGC SAVE_HOOK = null; public void isAlive() { System.out.println(\u0026#34;i am still alive\u0026#34;); } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\u0026#34;finalize method executed!\u0026#34;); EscapeGC.SAVE_HOOK = this; } } public class EscapeGCTest { @Test public void testEscapeGC() throws Exception { EscapeGC.SAVE_HOOK = new EscapeGC(); EscapeGC.SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (EscapeGC.SAVE_HOOK != null) { EscapeGC.SAVE_HOOK.isAlive(); } else { System.out.println(\u0026#34;i am dead\u0026#34;); } EscapeGC.SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (EscapeGC.SAVE_HOOK != null) { EscapeGC.SAVE_HOOK.isAlive(); } else { System.out.println(\u0026#34;i am dead\u0026#34;); } } } 结果：\nfinalize method executed!\ni am still alive\ni am dead\n","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/5_discarded_object_detection/","summary":"虽然不想放弃，但是总有别离","title":"内存废弃对象检测"},{"content":"标记清除算法 分为“标记 ”和“清除 ”两个阶段，首先标记出所有需要回收的对象，之后统一回收所有被标记的对象。\n效率低 清除后会产生大量的不连续内存碎片，会影响后续的对象分配 复制算法（新生代） 内存划分为大小相等的两块，每次只能使用其中一块。当这一块的内存用完了，就将存活的对象复制到另一块上，然后将已经使用过的内存空间一次性清理掉。\n高效 内存缩小为原来的一半 商用实现：将内存分为一块大的Eden和两块小的Survivor空间（分别叫from和to），一般比例为8:1，每次将Eden和一个Survivor上存活的对象复制到另一个Survivor空间上，当Survivor空间不足够时，需要依赖其他内存（老年代）进行分配担保。\nJVM区域：总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space（幸存者区）、Tenured Gen（老年代-养老区）。非heap区又分：Code Cache（代码缓存区）、Perm Gen（永久代）、JVM Stack（java虚拟机栈）、Local Method Stack（本地方法栈）。\n标记-整理算法（老年代） 分为“标记”和“整理”，标记出所有存活的对象，然后让所有存活的对象移动至内存一端，然后清空端边界以外的内存。\n分代收集算法 将内存分为新生代与老年代，然后使用复制算法和标记-整理算法结合\n","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/6_garbage_collection/","summary":"没用的时候，就要立刻抛弃","title":"垃圾回收算法"},{"content":" 优先在Eden区域分配 大对象直接进入老年代 长期存活的对象进入老年代 每个对象定义了一个对象年龄计数器（Age），当对象在Eden出生且存活，每次回收后Age便加一，当达到一定程度（一般15岁）时，将被移入老年代 动态对象年龄判断 当Survivor空间中某一年龄的对象达到Survivor的一半时，比其年龄大的对象直接进入老年代 空间分配担保 在Minor GC之前，会判断老年代的剩余空间是否大于新生代所有对象大小，如果条件成立，那么Minor GC是安全的 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/7_object_allocation_strategy/","summary":"原来对象也分出身","title":"对象在内存中的分配策略"},{"content":" Class文件的生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）\n类的加载时机 遇到new、getstatic、putstatic、invokestatic时，当类没有进行过初始化，则需要先触发其初始化 使用java.lang.reflect包的方法对类进行反射调用的时候 当初始化一个类时，发现其父类没有初始化，则先触发其父类的初始化 虚拟机启动时，会先初始化包含main()方法的类 使用JDK1.7的动态语言支持时，当java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatice、REF_invokeStatic的方法句柄，并且这个方法所对应的句柄所对应的类没有进行初始化 加载（Loading） 通过类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 验证（Verification） 文件格式的检验：是否以0xCAFEBABE开头、主次版本号是否在虚拟机处理的范围内等 源数据验证：进行语义校验，防止存在不符合Java语言规范的元数据信息 字节码验证：通过数据流和控制流分析，确定程序语义是合法，符合逻辑的 符号引用验证：对类自身以外的信息进行匹配性校验 准备（Preparation） 正式为类变量（被static修饰的变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。\n在此阶段，类变量如果不是final，则初始值为数据类型的默认值，如果是final，则初始化为被赋的值。\n解析（Resolution） 将常量池内的符号引用替换为直接引用的过程\n符号引用：用符号描述所引用的目标，可以是任何形式的字面量，与虚拟机的内存布局无关 直接引用：是直接指向目标的指针，偏移量或者句柄，与内存的布局有关 初始化（Initialization） 是类加载过程的最后一步 是执行\u0026lt;clinit\u0026gt;()方法的过程 编译器自动收集类中的所有类变量的赋值动作和静态语句块，静态语句块只能访问到定义在块之前的变量，定义在它之后的变量，只能赋值，不可访问 在子类的\u0026lt;clinit\u0026gt;()方法执行之前，父类的\u0026lt;clinit\u0026gt;()方法已经执行完毕 对于类或接口不是必须的，如无静态语句块和变量赋值操作，就不需要生成\u0026lt;clinit\u0026gt;()方法 接口中不能使用静态语句模块 多线程同时初始化一个类时，只会有一个线程执行\u0026lt;clinit\u0026gt;()方法，其他线程都要等待\u0026lt;clinit\u0026gt;()方法被执行完毕 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/8_class_loading/","summary":"原来还有这么多门道","title":"类加载机制"},{"content":"判断两个类是否相等，只有这两个类是同一个类加载器加载的前提下才有意义\n存在两类类加载器：\n启动类加载器：用C++实现，是虚拟机的一部分 其他类的类加载器：用Java语言实现，独立于虚拟机外部，继承自java.lang.ClassLoader 类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。除了顶层的启动类加载器外，其余都有自己的父类加载器。\n当类加载器收到了类加载的请求，它不会自己去尝试加载这个类，而是将类委派给父类加载器去完成，故所有的加载请求最终都应被传送到顶层的启动类加载器中，当父类返回无法加载此类时，子类加载器才会尝试自己去加载。\n","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/9_class_loader/","summary":"目前还没见过什么实际应用，了解就好","title":"类加载器"},{"content":"栈帧（Stack Frame） 是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈（Virtual Machine Stack） 的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到了方法表的Code属性中。对于执行引擎来讲，活动线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），这个栈帧所关联的方法称为当前方法（Current Method）。\n局部变量表 在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量 通过索引定位方式使用局部变量表，范围是从0~最大Slot数量 在方法执行时，如果是实例方法，那么局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot 局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用 局部变量不像前面介绍的类变量那样存在“准备阶段“，局部变量不会被赋值系统的默认值，如果一个局部变量定义了但没有赋初始值是不能使用的 操作数栈 操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中 操作数栈的每一个元素可以是任意Java数据类型，包括long和double。32位数据类型所占的栈容量为1（4字节），64位数据类型所占的栈容量为2（8字节） 当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作 在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了 动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接 在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析 另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接 方法返回地址 当一个方法被执行后，有两种方式退出这个方法：\n第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口（Normal Method Invocation Completion） 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用throw字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的 方法退出的过程实际上等同于把当前栈帧出栈：\n恢复上层方法的局部变量表和操作数栈 把返回值（如果有的话）压入调用栈帧的操作数栈中 调用PC计数器的值以指向方法调用指令后面的一条指令 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/10_run-time_stack_frame_structure/","summary":"看之前需要一点计算机架构的基础","title":"运行时栈帧结构"},{"content":"方法调用并不等同于方法执行，方法调用的唯一目的就是确定被调用方法的版本（即调用哪个方法）\n解析 在Java虚拟机规范第三版中，规定了5条方法调用指令： invokestatic：调用静态（类）方法。 invokespecial：调用实例方法，特化于super方法调用（父类方法），private方法及实例构造器方法 invokevirtual：调用一般实例方法（包括声明为final,但不为private的实例方法）。 invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象重写的具体方法 invokedynamic：调用动态方法（Java7中新增） 被invokestatic和invokespecial调用的方法都是非虚方法，符合这些条件的有：静态方法，私有方法，实例构造器，父类方法（虽然声明为final的方法是用invokevirtual指令调用的，但是我们知道，final方法不能被重写，无法产生多态行为，final方法的行为是非虚的，因此Java虚拟机规范明确说明了final方法是非虚方法）。这些方法在类加载的时候就会把符号引用解析为该方法的直接引用 分派 变量被声明时的类型叫做变量的静态类型（static type)，又叫做外观类型(Apparent Type)。 变量所引用对象的真实类型叫做变量的实际类型（Actual Type)。 Object obj = new Random()，obj的静态类型是Object,它的实际类型是Random。一个变量的静态类型是不能改变的，在编译期就完全确定下来，就像变量obj，无论怎样，在同一个作用域内，它只能是Object类型，当然了在使用的时候，还是可以对它进行强制类型转换 静态分派 发生在编译期，分派是根据静态类型信息发生 发生在编译阶段，因此静态分派的动作不是由虚拟机来执行的 根据接收者的静态类型和方法参数的静态类型来定位方法执行版本的 典型应用是方法重载 动态分派 动态分派选择的依据是被调用方法所在对象的运行时类型，也就是接收者的实际类型 方法参数的类型在动态分派选择时将不再起到作用 动态分派的重要体现是重写 可以重写的方法一定是虚方法，在调用虚方法时使用的指令是invokevirtual，invokevirtual指令的运行时解析过程大致分为以下步骤： 找到操作数栈顶的第一个元素所指向对象的实际类型，记作C。也就是找到接收者的实际类型。 如果在类型C中找到相符的方法，进行校验，返回方法的直接引用，查找结束，校验不通过，抛异常。 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和校验过程。 如果始终没找到，抛异常。 单分派和多分派 方法的接收者和方法的参数统称为方法的宗量，根据分派基于多少宗量，又可以分成单分派和多分派 静态分派中，编译器要判断接受者的静态类型，确定是哪个类上的方法，这个时候已经判定了接受者这个宗量了，编译器还需要确定参数的静态类型，已确定重载方法中的版本，这个时候又判定了参数这个宗量。所以静态分派是多分派 到了运行期，虚拟机首先就是判断接收者的实际类型，去其上搜索匹配的方法，只判定了接收者的实际类型，方法参数的类型已经不重要了。所以动态分派是单分派 动态类型语言支持 在java7 JVM中增加了一个新的指令invokedynamic，用于支持动态语言，即允许方法调用可以在运行时指定类和方法，不必在编译的时候确定 具体步骤： 根据invokedynamic指令后面的限定符#n，找到调用点限定符在常量池中的位置，调用点限定符的符号引用为CONSTANT_InvokeDynamic_info结构： CONSTANT_InvokeDynamic_info{ u1 tag; u2 bootstrap_method_attr_index; u2 name_and_type_index; } 通过CONSTANT_InvokeDynamic_info结构，找到引导方法，引导方法返回值必须是Java.lang.invoke.CallSite类型 调用引导方法。和调用普通方法一样：动态调用点限定符的符号引用解析时出现了异常、或者引导方法执行出现异常、或者引导方法的返回值不匹配、MethodHandle方法描述不一致等都会抛出BootstrapMethodError异常。 执行完引导方法之后，动态调用点会返回一个调用点对象（CallSite）、此对象将会与动态调用点永久绑定，随后调用点对象的MethodHandle将会被调用，即调用invoke、invokeExact等方法。 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/11_method_call/","summary":"原来是这么区分同名方法的","title":"方法调用"},{"content":"Java语言中 ，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。\n基于栈的指令集与基于寄存器的指令集 Java编译器输出的指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA）指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。 iconst_1 iconst_1 iadd istore_0 基于栈的指令集主要的优点就是可移植 栈架构指令集的主要缺点是执行速度相对来说会稍慢一些 虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量 x86的二地址指令集 mov eax ,1 add eax ,1 基于栈的解释器执行过程 从Java语言的角度来看，这段代码没有任何解释的必要\n具体执行步骤由下图表示：\n","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/12_stack_based_bytecode_interpretation_executor/","summary":"基本进入了汇编语言的范畴","title":"基于栈的字节码解释执行引擎"},{"content":"主内存与工作内存 Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示：\n这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分，如果勉强要进行对应，主内存对应于Java堆中的对象实例数据，工作内存对应虚拟机栈中的部分区域。\n内存间交互操作 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：\nlock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：\n不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作） 重排序 在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：\n编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：\n为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种：\n屏障类型 指令示例 说明 LoadLoad Barriers Load1; LoadLoad; Load2 确保Load1的数据装载，之前于Load2及后续所有装载指令的装载 StoreStore Barriers Store1; StoreStore; Store2 确保Store1的数据对其他处理器可见（刷新到内存），之前于Store2及后续所有存储指令的存储 LoadStore Barriers Load1; LoadStore; Store2 确保Load1的数据装载，之前于Store2及后续所有存储指令刷新数据到内存 StoreLoad Barriers Store1; StoreLoad; Load2 确保Store1的数据对其他处理器可见（刷新到内存），之前于Load2及后续所有装载指令的装载 StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令\nvolatile型变量 当一条线程对其改变时，所有线程都会立刻得知 不是线程安全的（在获取变量时立刻得知，但是其他线程对其修改时可能不是原子的） 禁止指令重排序优化 原子性、可见性与有序性 原子性（Atomicity）：由内存模型的规则保证原子性的变量操作。基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的（但是虚拟机可以选择将其实现为原子操作，故不需在意）。 可见性（Visibility）：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。 Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。 无论是普通变量还是volatile变量都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。 除了volatile关键字能实现可见性之外，还有synchronized和final。 有序性（Ordering）：Java中天然的有序性用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn-Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。 Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性，volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现。 在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。 先行发生（happens-before）原则 Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。\n程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。 管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。 volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。 线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。 线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。 线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。 对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。 传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/13_memory_model/","summary":"初窥高迸发","title":"内存模型"},{"content":"线程的实现 实现线程主要有3种方式：\n使用内核线程实现 内核线程（Kernel-Level Thread）是由操作系统支持的线程，程序一般使用内核线程的一种高级接口——轻量级进程（Light Weight Process） 轻量级进程与内核线程间是一对一的线程模型 使用用户线程实现 不是内核线程的线程被称为用户线程 狭义上是完全建立在用户空间的线程库上的，创建、同步、销毁、调度完全在用户态完成 一般是一对多的线程模型 消耗低但是所有操作都需要用户程序自己处理，现在几乎不会使用 使用用户线程加轻量级进程混合实现 用户线程还是建立在用户空间中 轻量级进程作为用户线程和内核线程的桥梁 是多对多的模型 Java线程的实现：在Windows和Linux中，一条Java线程对应一条轻量级进程。在Solaris中，是可以同时支持一对一和多对多的。\nJava线程调度 协同式线程调度 线程的执行时间由线程本身控制 实现简单，不存在同步的问题 但是执行时间不可控，如果编写有问题，那么程序将一直阻塞 抢占式线程调度（Java采用） 由系统分配执行时间，切换不由线程本身来决定 Java有10个线程优先级，可以建议系统为线程分配更多时间，但是根据操作系统不同，线程优先级的效果可能不同\n状态切换 新建（NEW）：新创建了一个线程对象。 可运行（RUNNABLE）：线程对象创建后，其他线程（比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权 。 运行（RUNNING）：可运行状态（runnable）的线程获得了cpu时间片（timeslice），执行程序代码。 阻塞（BLOCKED）：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行（runnable）状态，才有机会再次获得cpu timeslice 转到运行（running）状态。阻塞的情况分三种： 等待阻塞：运行（running）的线程执行o.wait()方法，JVM会把该线程放入等待队列（waitting queue）中。 同步阻塞：运行（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中。 其他阻塞：运行（running）的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行（runnable）状态。 死亡（DEAD）：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/14_thread/","summary":"和操作系统的线程有一点不一样","title":"线程"},{"content":" 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替运行，并且在主调试代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，则称这个类是线程安全的。线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。\nJava中各种操作共享数据 不可变 不可变的对象一旦被建立，其外部的可见状态永远也不会改变，故是安全的 一般为final修饰的数据，String、java.lang.Number的部分子类等 绝对线程安全 无论运行时环境如何，调用者都不需要任何额外的同步措施 付出代价过大，甚至是不切实际的代价 相对线程安全 通常意义的线程安全 单独的操作是线程安全的 对于特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性 线程兼容 对象本身不是线程安全的，但是在调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用 Vector和HashTable对应的ArrayList和HashMap等就属于线程兼容的 线程对立 无论是否采取同步措施，都无法正确执行并发 Thread类中的suspend()和resume()方法，无论是否进行同步，并发进行的话都会出现死锁 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/15_thread_safety/","summary":"什么才是安全？","title":"线程安全"},{"content":"多线程同步方案 sychronized volatile wait()和notify() Lock 无同步方案 存在一些代码天生就是线程安全的，故不需要同步方案 可重入代码：不依赖在堆上的数据和公用的系统资源、用到的状态量都是由参数传入。即一个方法是可预测的，输入了相同的数据，都能返回相同的结果，就满足可重入性 线程本地存储：共享数据的所有代码在一个线程中执行，就可以把共享数据的看见范围限制在线程之内，“生产者-消费者”模式和web交互模型的“一个请求对应一个服务器线程”就是这类的应用 乐观锁和悲观锁 乐观锁：假设冲突不经常发生，先提交操作，如果失败就重试 悲观锁：假设会发生冲突，有强烈的独占和排他性 乐观锁应用 非阻塞同步 先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果存在争用，那么便产生了冲突，是一种乐观并发策略 CAS操作 比较并交换，Compare-and-Swap，可以通过一条处理器指令完成 java.util.concurrent.atomic包下的原子类型变量，如：AtomicInteger，使用了底层的JVM支持，为数字类型提供CAS操作 CAS操作会出现ABA问题，解决：不只更新引用值，而是更新引用+版本号，即使出现ABA，版本号也不同 悲观锁应用 互斥同步（Mutual Exclusion \u0026amp; Synchronization） 保证共享数据在同一时刻只能被一个线程使用，互斥是方法，同步是目的。临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）都是实现互斥的手段\nsynchronized关键字 Java中互斥同步的手段就是synchronized关键字，经过编译后，会在同步块前后形成monitorenter和monitorexit两个字节码指令，当执行monitorenter时，首先要尝试获取对象锁，如果对象没有被锁定，或者当前对象已经拥有了锁，就把锁的计数器加1，如果执行到monitorexit时，计数器减1，当计数器为0时，锁就被释放；当获取对象锁失败，线程就要阻塞等待，直到对象锁被另一个线程释放\nReentrantLock重入锁 java.util.concurrent包中的重入锁ReentrantLock实现同步，机制类似，只是一个是API层面的互斥锁，一个是原生语法层面的互斥锁 http://www.cnblogs.com/zhengbin/p/6503412.html\nReentrantLock实现 ReentrantLock实现了Lock接口，内部有三个内部类，Sync、NonfairSync、FairSync，Sync是一个抽象类型，继承AbstractQueuedSynchronizer；AbstractQueuedSynchronizer是一个模板类，实现了许多和锁相关的功能，如tryAcquire，tryRelease等。Sync实现了AbstractQueuedSynchronizer的tryRelease方法。NonfairSync和FairSync两个类继承自Sync，实现了lock方法，然后分别公平抢占和非公平抢占针对tryAcquire有不同的实现。\n流程图(非公平锁抢占) ReentrantLock的lock方法的时候，实际上调用NonfairSync的lock方法，该方法先用CAS操作尝试抢占该锁。如果成功，把当前线程设置在这个锁上，表示抢占成功。如果失败，调用acquire模板方法，等待抢占 acquire方法内部使用tryAcquire这个钩子方法尝试再次获取锁 tryAcquire一旦返回false，就会则进入acquireQueued流程，使用锁队列（本质：双向链表）实现，当前一个节点释放时，当前节点唤醒\n重入锁之所以可以重入，是同一个线程可以反复使用其占用的锁，相当于一个偏向锁 补充：AbstractQueuedSynchronizer（AQS）\nAQS使用一个int类型的volatile变量（命名为：state）维护同步状态 实现锁的获取require()与释放release() 排他模式（exclusive mode）和共享模式（shared mode） require()至少调用一次tryAcquire()，同理release() 与synchronized区别\nsynchronized是原语层面的互斥锁，而ReentrantLock是API层面的互斥锁 都可以线程重入（同一个线程可以反复使用其占用的锁，相当于一个偏向锁） 但ReentrantLock增加的3个功能 等待可中断：持有锁的线程长期不释放锁，等待锁的线程可放弃等待 可实现公平锁：公平锁指：多个线程等待同一个锁时，必须按照申请的顺序依次获得锁（默认是：非公平锁） 锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象（多次调用newCondition()方法），而synchronized只能一个（条件：等待某个条件满足前，一直挂起该线程） 关键：1）volatile修饰state，判断是否有加锁；2）AQS同步器实现锁的获取与释放； TryAcquire()方法：如果锁state为0则尝试获取锁，否则：识别获取锁的线程是否为当前占据锁的线程，如果是再次成功获取 信号量Semaphore 信号量是对锁的扩展，sychronized和重入锁ReentrantLock一次只允许一个线程访问一个资源，信号量可以指定多个线程同时访问一个资源 信号量可以用于做流量控制，控制最大并发量 信号量可以控制程序逻辑：singal(S), wait(S) 实现与ReentrantLock一样，依靠继承自AbstractQueuedSynchronizer的Sync实现主要功能，只是调用共享模式的：tryAcquireShared()方法 ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/16_thread_safety_implement/","summary":"我有很多办法实现安全，很多种","title":"线程安全实现"},{"content":"自旋锁与自适应自旋 互斥部分的代码执行时间一般很短 不再让冲突的线程等待（阻塞恢复的代价是很大的-线程阻塞和唤醒需要CPU从用户态转为核心态），而是让线程进入一个忙循环（自旋） 如果自旋超过一定次数，就让冲突的线程阻塞 自适应自旋就是根据前一次在相同锁上的自旋时间来决定本次自旋的时间 锁消除 即时编译器在运行时，对代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除 锁粗化 当一系列连续的操作都对一个对象进行反复的加锁和解锁，甚至加锁操作是放在循环体中的，会出现大量的性能损耗，锁粗化就是将这些操作合并在一个同步块中 偏向锁 锁第一次被线程获取的时候，用CAS把获取锁的线程ID记录在Mark Word中，如果CAS成功，则持有偏向锁，每次线程进入锁的同步块时，都不需要进行同步操作 当另一个线程获取该锁时，偏向模式就结束了，根据现在对象是否被锁定恢复到未锁定“01”或者轻量级锁定“00”，后续的同步操作依照轻量级锁执行 适用于只有一个线程访问同步块的场景 轻量级锁 利用对象的头信息中的“Mark Word”部分，使用CAS操作尝试将其更新为指向Lock Record的指针（包含owner和Displaced Mark Word（用于存放原Mark Word的））。 如成功说明已经拥有锁，标志位转为“00” 如果失败，首先检查“Mark Word”是否指向当前栈帧，如果是，直接进入同步块，否则说明锁对象已经被其他线程抢占，膨胀为重量级锁，标志位变成“10” 解锁过程使用CAS将Displaced Mark Word替换到Mark Word部分，如果替换成功，同步完成，替换失败，说明有其他线程尝试获取该锁，在释放的同时，唤醒被挂起的线程 提升性能是依据绝大部分锁是不存在竞争这一前提下的 偏向锁、轻量级锁、重量级锁三者各自的应用场景\n偏向锁：只有一个线程进入临界区； 轻量级锁：多个线程交替进入临界区； 重量级锁：多个线程同时进入临界区。 锁只可以升级而不可以降级，即：偏向锁升级成轻量级锁后不能降级成偏向锁\n例子\nsynchronized (lockObject) { // do something } 假设上面同步代码块中存在一个临界区，当前存在Thread#1和Thread#2两个用户线程，分三种情况来讨论：\n情况一：只有Thread#1会进入临界区； 情况二：Thread#1和Thread#2交替进入临界区； 情况三：Thread#1和Thread#2同时进入临界区。 情况一是偏向锁的适用场景，当Thread#1进入临界区时，JVM会将lockObject的对象头Mark Word的锁标志位设为“01”，同时会用CAS操作把Thread#1的线程ID记录到Mark Word中，此时进入偏向模式。所谓“偏向”，指的是这个锁会偏向于Thread#1，若接下来没有其他线程进入临界区，则Thread#1再出入临界区无需再执行任何同步操作。也就是说，若只有Thread#1会进入临界区，实际上只有Thread#1初次进入临界区时需要执行CAS操作，以后再出入临界区都不会有同步操作带来的开销。\n然而情况一是一个比较理想的情况，更多时候Thread#2也会尝试进入临界区。若Thread#2尝试进入时Thread#1已退出临界区，即此时lockObject处于未锁定状态，这时说明偏向锁上发生了竞争（对应情况二），此时会撤销偏向，Mark Word中不再存放偏向线程ID，而是存放hashCode和GC分代年龄，同时锁标识位变为“01”（表示未锁定），这时Thread#2会获取lockObject的轻量级锁。因为此时Thread#1和Thread#2交替进入临界区，所以偏向锁无法满足需求，需要膨胀到轻量级锁。\n再说轻量级锁什么时候会膨胀到重量级锁。若一直是Thread#1和Thread#2交替进入临界区，那么没有问题，轻量锁hold住。一旦在轻量级锁上发生竞争，即出现“Thread#1和Thread#2同时进入临界区”的情况，轻量级锁就hold不住了。 （根本原因是轻量级锁没有足够的空间存储额外状态，此时若不膨胀为重量级锁，则所有等待轻量锁的线程只能自旋，可能会损失很多CPU时间） 重量级锁线程竞争不使用自旋，不消耗CPU，但是有线程阻塞，轻量级锁自旋\n","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/17_lock_optimization/","summary":"锁，也是分很多种滴","title":"锁优化"},{"content":"定义 为避免系统频繁地创建和销毁线程，让创建的线程复用 Executors是一个静态工厂类，可以取得特定功能的线程池 不同特性的线程池（Executors中获取） newFixedThreadPool() 返回固定数量的线程池 当有新任务提交时，线程池中若有空闲线程，则立即执行，否则将任务放入任务队列 newSingleThreadExecutor() 返回只有一个线程的线程池 newCachedThreadPool() 返回一个可以根据实际情况调整线程数量的线程池，任务增多线程增加，任务减少线程减少 newScheduledThreadPool() 返回可指定线程数量的ScheduledExecutorService对象的定时线程池，可以：1）给定时间执行某任务（schedule()）；2）周期性执行某任务（scheduleAtFixedRate()）；3）固定延迟后，周期性执行某任务（scheduleWithFixedDelay()）。 ThreadPoolExecutor线程池类 关键构造函数参数 corePoolSize：核心线程池的大小，默认情况下，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到阻塞队列当中 maximumPoolSize：线程池最大线程数 keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize unit：参数keepAliveTime的时间单位 workQueue：阻塞队列，用来存储等待执行的任务 关键数据结构 HashSet\u0026lt;Worker\u0026gt; workers：一个worker对应一个线程，线程池通过workers包含多个线程 BlockingQueue\u0026lt;Runnable\u0026gt; workQueue：当线程池中的待处理任务数数超过容量，任务提交后，进入阻塞队列，等待worker线程 关键方法 execute()：核心方法，向线程池提交一个任务，并执行 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); // 如果线程池中当前线程数小于核心池大小 if (workerCountOf(c) \u0026lt; corePoolSize) { // addWorker if (addWorker(command, true)) return; c = ctl.get(); } // 如果当前线程池处于RUNNING状态，则将任务放入缓存队列 if (isRunning(c) \u0026amp;\u0026amp; workQueue.offer(command)) { int recheck = ctl.get(); // 下面：为防止将任务添加进任务缓存队列时，其他线程调用shutdown或shutdownNow关闭线程池 if (!isRunning(recheck) \u0026amp;\u0026amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 否则addWorker else if (!addWorker(command, false)) // 如果失败，拒绝任务处理 reject(command); } addWorker() Worker w = new Worker(firstTask); final Thread t = w.thread; // Worker实现Runnable接口，有run方法 使用 import java.io.Serializable; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; public class ThreadPoolExecutorDemo { static int consumeTaskSleepTime = 5; public static void main(String[] args) { //构造一个线程池，阻塞队列小，会有部分任务丢失 ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 4, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue\u0026lt;\u0026gt;(5), new ThreadPoolExecutor.DiscardOldestPolicy()); // 其中：ThreadPoolExecutor.DiscardOldestPolicy()是任务拒绝策略：丢弃队列最前面的任务，然后重新尝试执行任务 for (int i = 1; i \u0026lt;= 20; i++) { //定义最大添加20个线程到线程池中 try { //一个任务，并将其加入到线程池 String work = \u0026#34;work@ \u0026#34; + i; System.out.println(\u0026#34;put ：\u0026#34; + work); threadPool.execute(new ThreadPoolTask(work)); //便于观察，等待一段时间 Thread.sleep(1); } catch (Exception e) { e.printStackTrace(); } } } /** * 线程池执行的任务 */ public static class ThreadPoolTask implements Runnable, Serializable { private static final long serialVersionUID = 0; //保存任务所需要的数据 private Object threadPoolTaskData; ThreadPoolTask(Object works) { this.threadPoolTaskData = works; } public void run() { //处理一个任务 System.out.println(\u0026#34;start------\u0026#34; + threadPoolTaskData); try { //便于观察，等待一段时间 Thread.sleep(consumeTaskSleepTime); } catch (Exception e) { e.printStackTrace(); } threadPoolTaskData = null; } } } ","permalink":"https://victor-zhc.github.io/posts/computer/java/java_virtual_machine/18_thread_pool/","summary":"资源也是可以复用的","title":"线程池"},{"content":"Overview 组件 自包含的功能软件单元，包括：Web组件和EJB组件 Web组件，如：servlet, JSP EJB组件，如：enterprise bean 两种类型的enterprise bean: session bean和message-driven bean Session Bean：为客户端提供服务，分为两种，有状态（每次返回新的SessionBean）和无状态（每次返回同一个SessionBean） Message Driven Bean，基于JMS（Java Message Service），有两种工作模型：p2p（点对点），发布订阅模型 容器 支持组件和底层平台功能的接口，3类： Java EE服务器，包括：EJB容器和Web容器 应用客户端容器 Applet容器 部署描述文件 2种： Java EE部署描述文件 运行时部署描述文件 四种类型的JavaEE模块 EJB模块 Web模块 Application Client模块 Resource Adapter模块 JSTL JSP标准标签库（JavaServer Pages Standard Tag Library） JPA Java Persistence API 将运行对象持久化到数据库中 注：Java持久化包括三部分： JPA； 查询语句； 对象/关系 映射元数据； JTA Java Transaction API JAX-RS Java API for RESTful Web Services JMS Java Message Service API create, send, receive and read messages SSH框架 Struts：表示层 Spring：应用层、业务层 Hibernate：持久层、数据层 ","permalink":"https://victor-zhc.github.io/posts/computer/java/javaee_and_middleware/1_overview/","summary":"提前给你搭好架子","title":"概览"},{"content":"Web应用请求处理过程 步骤： client发送HTTP请求给web server 采用servlet和jsp实现的web server转变请求为HTTPServletRequest对象，分发到恰当的组件上 Web组件和Javabean组件交互产生动态内容 Web组件、Javabean组件和数据库交互产生动态内容 Web组件生成最终的HTTPServletResponse响应对象 Web server将该响应对象转化为HTTP Response，返回给客户端 HttpServlet类 doGet和doPost方法 web模块结构 Assembly Root：根目录包括子文件夹WEB-INF WEB-INF包括： classes：包括服务器端类 tags：自定义标签或标签库 lib：jar文件 部署描述文件：web应用是web.xml，EJB应用是ejb-jar.xml Servlet技术 是服务器端的小程序，用于扩展服务器的能力 Servlet技术默认是多线程的，request和response是线程安全的 Servlet生命周期由所属容器控制 当客户端请求发送到服务器时，容器执行以下步骤 如果servlet实例不存在 a. 加载servlet类； b. 创建一个servlet实例； c. 调用init方法初始化实例 调用service方法，传递request和response对象 移除servlet时，调用destroy()释放 注释为@WebServlet 开发HttpServlet步骤 扩展HttpServlet类； init() { super.init() }； 定制service()方法； DTD文档类型定义 Document Type Definition 定义了XML文档的结构和元素的顺序 Session Web应用采用session跟踪应用的状态 session有timeout机制，过时失效 Web容器在客户端和服务器端传送标识符Session ID Session实现的两种机制：Cookie机制和URL重写 https://www.cnblogs.com/xdp-gacl/p/3855702.html Cookie机制 步骤： 用户第一次访问站点，创建新的会话对象（Httpsession），Server分配唯一的标识号（sessionID） Server创建一个暂时的HTTP cookie 客户浏览器发送包含Cookie的请求 根据客户机浏览器发送的sessionID信息（Cookie），Server找到相应的HttpSession对象，跟踪会话 会话超时则失效 URL重写 ###步骤：\n用户第一次访问站点，创建新的会话对象（Httpsession），Server分配唯一的标识号（sessionID） Server将sessionID放在返回给客户端的URL中 客户浏览器发送包含sessionID的请求 根据包含请求的sessionID信息（URL），Server找到相应的HttpSession对象，跟踪会话 会话超时则失效 四种作用域对象 Web Context Session（一个人多个页面） Request（一次请求） Page（用于JSP） 过滤器 多个filter按照web.xml中filter-mapping出现的顺序运行 主要任务包括： Query：查询请求并act Block：拦截 Modify：修改请求/响应 Interact：与其他资源交互 注释为@WebFilter 监听器 对生命周期进行管理 例如：统计访问web应用的次数 注释为@WebListener ","permalink":"https://victor-zhc.github.io/posts/computer/java/javaee_and_middleware/2_servlet/","summary":"替你搭好Web的架子","title":"Servlet"},{"content":"JSP Tomcat上最终执行Servlet类，以Servlet访问服务器 分为 动态内容，JSP元素：同Servlet； 静态内容； 优点：编译自动完成； 缺点：开发不知正确与否； JSP元素（动态内容） 包括： 指令：控制如何翻译； 脚本元素（Servlet方法）； 表达式语法； jsp:[set|get]Property； jsp:[include|forward]； jsp:plugin； 定制标签； JSP标准语法 注释 \u0026lt;%\u0026ndash; —%\u0026gt; 声明 \u0026lt;%! %\u0026gt; 指令 \u0026lt;%@ %\u0026gt; 包含include，页面page，标签库taglib 表达式 \u0026lt;%= %\u0026gt; 脚本 \u0026lt;% %\u0026gt; 指令 @page 控制不同的执行参数，名值对，中间以逗号隔开 session：servlet缺省无session，而JSP默认session=“true” import：导入包，以逗号隔开，常用包已默认导入 extends：扩展其他类 contentType：“text/html, charset=GBK”，设置文本类型和字符编码 buffer：输出先到缓冲区，缺省8192KB，JSP缺省有缓冲区，而servlet缺省无缓冲区，通过response.setBuffer(8192); 设置缓冲区 ThreadSafe：一般isThreadSafe=“true”，允许多线程 errorPage：页面异常，isErrorPage=”true”，表示是错误页面 @include 属性file，静态过程，类似于宏替换，优点：重用 servlet是通过请求分派器请求分派 @taglib 定制标签 TLD：.tld文件，是XML文件格式 标签处理器类：有 doTag() 和 set() 方法 脚本 创建实例变量或类变量，要在声明中创建 表达式 计算表达式，转换成String对象，插入到输出流中 ","permalink":"https://victor-zhc.github.io/posts/computer/java/javaee_and_middleware/3_jsp/","summary":"替你搭好前端的架子","title":"JSP技术"},{"content":"Hibernate API 映射文件hibernate.cfg.xml； SessionFactory：用户程序从中取得Session实例，是线程安全的； ConnectionProvider 生成JDBC连接的工厂； Session 持久层管理器，轻量级的类； Transaction 对实际事务实现的抽象，是单线程的； 向数据库添加记录 建立SessionFactory； 使用SessionFatory类的openSession方法获得一个Session对象； 使用Session接口的openTransation方法开始一个新事物； 使用Session接口的save方法保存实例； 成功commit，失败rollback； 关闭Session对象； HQL Hibernate Query Language 面向对象的查询语言，查询以对象形式存在的数据 Web应用中的线程安全 ResultSet、Statement和Hibernate中的Session等对象，不是线程安全的 可通过ThreadLocal类，产生可重入的线程安全的代码 Hibernate提供的HibernateUtil类 Spring Spring模块 所有模块都建立在核心容器上，容器规定如何创建、配置和管理bean等 数据访问/集成模块 包括JDBC、ORM、OXM、JMS和Transactions模块 ORM模块：Object/Relation Mapping对象关系映射，包含JPA、JDO和Hibernate Web模块 portlet模块：处理request并产生动态内容 portal：提供个性化，单点登录，不同源的内容聚合，与表示层集中 反向控制-loC\n思路 依赖倒置原则（DIP）的实现 Bob Martins对DIP的定义 高层模块不应该依赖于低层模块，两者应该依赖于抽象； 抽象不应该依赖于实现，实现应该依赖于抽象； 特点 实现松耦合； 对象被动接收依赖类而不是主动寻找； JNDI的反转； 面向切面-AOP\n思路 使用“横切”技术，将软件系统分为两个部分：核心关注点和横切关注点 主要处理 日志记录、性能统计、安全控制、事务处理、异常处理 特点 将业务逻辑从系统中分离出来； 内聚开发； 将服务模块化； 使用案例 https://www.cnblogs.com/hongwz/p/5764917.html 容器\n包含并管理系统对象的生命周期和配置 Spring模块的核心容器 Beans； Core； Context； spEL； struts Struts2工作流程： 请求资源； Filter Dispatcher确定action； Interceptors（拦截器）； Action方法执行； Action、Service、DAO层的设计 example Struts -\u0026gt; Action Spring -\u0026gt; Dao、Service Hibernate -\u0026gt; Model ","permalink":"https://victor-zhc.github.io/posts/computer/java/javaee_and_middleware/4_ssh/","summary":"替你搭好后端的架子","title":"SSH"},{"content":" Spring Boot Application类：@SpringBootApplication Main方法：SpringApplication.run(Application.class, args); @Autowired自动导入依赖的bean Spring Web MVC框架 @Controller负责业务控制，与页面交互，就是struts中的action @Service负责业务逻辑，就是service或manager @Repository持久层，就是dao @Component，就是组件，确定不了哪一层使用 Controller中注解 @RequestMapping返回值通常解析为跳转路径，将方法映射到HTTP请求 加上@ResponseBody，则不解析为路径 @PathVariable路径变量，如：/{id} RequestMapping(“user/get/mac/{id}”) public String getByMacAddress(@PathVariable int id){ } @RequestParam方法参数 public void deleteApi(@RequestParam(\u0026#34;id\u0026#34;) int id){ } 关于@RestController @RestController = @ResponseBody + @Controller 一般想返回string或者json则用@RestController，想页面跳转则用@Controller Service中注解 @Transactional(readOnly = true) @Transactional规定接口、类或者方法必须应用事务的元数据语法 JPA注解 @Entity @Table：表明这是一个实体类，一般一起使用，如果表名和实体类名相同，则@Table可省略 @Colum：如果字段名与列名相同，可省略 @Id：主键 application.properties中设置属性值 ","permalink":"https://victor-zhc.github.io/posts/computer/java/javaee_and_middleware/5_spring-boot/","summary":"更好用的Spring","title":"spring-boot"},{"content":"JDBC读取数据数据的过程 两种建立数据库连接的方式 DriverManager机制 DataSource机制 两者区别：DataSource是从连接池找一个连接，而DriverManager是创建一个连接 向数据库提交查询请求 读取查询结果 处理查询结果 释放连接 MVC 通过控制器将模型和视图分开，单独开发，易于修改 三部分 View：呈现给用户的界面，JSP或应用GUI Model：封装应用数据，EJB适合 Controller：接受用户动作，并对应用数据进行适当处理，Servlet适合 中间件 定义：在操作系统和应用系统之间的一层软件，为分布式应用的开发、部署、运行和管理提供支持 技术集合 远程过程调用：stub客户端代理，skeleton服务器端代理 远程数据库访问：程序与数据库之间通信，如：JDBC 分布式事务处理：数据库与中间件协议\u0026mdash;XA协议，两阶段提交 消息队列 CORBA Common Object Request Broker Architecture，公共对象请求代理程序体系结构 两类Enterprise Bean 会话Bean 同步，非持久的（数据不保存到数据库） 有三种类型： 有状态（Stateful） 使用场景： a. 特定的客户端 b. 需要跨方法调用 c. 客户端需要与其他组件交互 d. 该会话Bean需要与多个EJB交互才能实现 无状态（Stateless） 可以实现Web Service，但是Stateful Bean不行 单例（Singleton） 仅一个会话Bean，可以实现Web Service 消息驱动Bean 异步 Entity Life Cycle 4个状态 New：新建实例，容器用； Managed：有持久性标识符； Detached：分离状态； Removed：删除状态； 方法 persist()：存储到数据库，支持级联更新； merge()：容器决定flush时，数据将同步到数据库中； JMS技术 JMS：Java Message Service 应用：进程间通信，异步传递消息 ","permalink":"https://victor-zhc.github.io/posts/computer/java/javaee_and_middleware/6_other/","summary":"看看还有什么好用的玩意儿","title":"其它"}]